\chapter{Entwurf einer Modellierungssprache für Test-Daten}
\label{chap:modellierung}

Ein Ziel dieser Arbeit ist es, die Modellierung von Testdaten zu vereinfachen. DbUnit ist eine bewährte
Bibliothek zur Unterstützung von Unit-Tests datenbankbasierter Anwendungen. Welche Schwächen DbUnit-DataSets
in Bezug auf die Modellierung haben, wurde bereits in Abschnitt \ref{sec:fragestellung:modellierung}
thematisiert. 

Ein üblicher Weg, bestehende Schnittstellen zu vereinfachen, stellen Fassaden dar.
Eine solche Fassade kann auf unterschiedliche Arten realisiert werden.

Eine Möglichkeit stellt die Definition einer speziellen Sprache dar. Eine solche, für einen Anwendungszeck
definierte Sprache wird als \textit{Domänenspezifische Sprache} (engl. Domain-Specific Language, abgekürzt DSL)
bezeichnet.

Das von \textit{SB Testing DB} bereitgestellte Fluent Interface stellt bereits eine Form einer DSL dar. Eine
solche DSL, die vollständig in eine andere Sprache eingebettet ist und im Wesentlichen die Sprachelemente dieser
Sprache nutzt, wird als \textit{interne DSL} bezeichnet \cite[68]{DOMAIN_SPECIFIC_LANGUAGES}. 

In diesem Abschnitt soll eine Modellierungssprache für Test-Daten entwickelt werden. Die Vor- und Nachteile
der in Kapitel \ref{chap:anforderungen} diskutierten Modellierungsvarianten sollen in die Sprache einfließen.
Die Syntax dieser Sprache darf unabhängig von Java sein, so dass sie auch als \textit{externe DSL} realisiert
werden kann. Der Vorteil von externen gegenüber internen DSLs besteht in der größeren Freiheit in Bezug auf
die Syntax \cite[89]{DOMAIN_SPECIFIC_LANGUAGES}. 

\section{Entwurf der DSL}
\label{sec:implementierung:entwurf}

Als Grundlage für die Defintion der Modellierungsprache sollen verschiedene Beispiel-Entwürfe dienen. Dabei wird
das fortlaufende Beispiel aus Kapitel \ref{chap:anforderungen} mit unterschiedlichen Entwürfen modelliert und
die Vor- und Nachteile analysiert.

Mit Hilfe dieser Analyse wird die finale Modellierungssprache definiert.


  \subsection{Beispiel-Entwurf 1}
  \label{sec:implementierung:entwurf:1}
  
  Eine DSL, die sich stark an \textit{SB Testing DB} orientiert, könnte wie folgt aussehen:
  
  \begin{lstlisting}[caption=Mögliche DSL (1), label=listing:dslentwurf1]
HAASE = professor {
  name      "Haase"
  vorname   "Oliver"
  titel     "Prof. Dr."
  fakultaet "Informatik"
}

WAESCH = professor {
  name      "Wäsch"
  vorname   "Jürgen"
  titel     "Prof. Dr.-Ing."
  fakultaet "Informatik"
}
  
VSYS = lehrveranstaltung {
  name      "Verteilte Systeme"
  sws       4
  ects      5
}
  
DPATTERNS = lehrveranstaltung {
  name       "Design Patterns"
  sws       4
  ects      3
}

...

HAASE leitet VSYS
HAASE leitet DPATTERNS
HAASE beaufsichtigt  P_DPATTERNS
WAESCH beaufsichtigt P_VSYS
...

  \end{lstlisting}
  
  Die in Listing \ref{listing:dslentwurf1} gezeigte DSL kommt ohne manuell vergebene ID-Nummern aus und verwendet
  Variablennamen für die Modellierung von Beziehungen. Da für jeden Wert eine eigene Zeile verwendet wird, werden
  umfangreiche Daten schnell unübersichtlich. Die Beschreibung der Beziehungen abseits der Definition der Daten
  erschwert den Umgang mit den Daten und die Übersicht ebenfalls.


  \subsection{Beispiel-Entwurf 2}
  \label{sec:implementierung:entwurf:2}
  
  Ein leicht abgewandelter Entwurf (siehe Listing \ref{listing:dslentwurf2}) zeigt, wie sich die Beziehungen näher an
  den eigentlichen Daten beschreiben lassen könnten.
  An dem Problem, dass die Daten relativ schnell in vertikaler Richtung wachsen, ändert das jedoch nichts.
    

  \begin{lstlisting}[caption=Mögliche DSL (2), label=listing:dslentwurf2]
HAASE = professor {
  name      "Haase"
  vorname   "Oliver"
  titel     "Prof. Dr."
  fakultaet "Informatik"
  leitet    VSYS, DPATTERNS
  beaufsichtigt  P_DPATTERNS
}

WAESCH = professor {
  name      "Wäsch"
  vorname   "Jürgen"
  titel     "Prof. Dr.-Ing."
  fakultaet "Informatik"
  beaufsichtigt  P_VSYS
}
  
VSYS = lehrveranstaltung {
  name      "Verteilte Systeme"
  sws       4
  ects      5
}
  
DPATTERNS = lehrveranstaltung {
  name       "Design Patterns"
  sws       4
  ects      3
}

...
  \end{lstlisting}
  

  \subsection{Beispiel-Entwurf 3}
  \label{sec:implementierung:entwurf:3}
    
  Listing \ref{listing:dslentwurf3} zeigt den dritten Entwurf einer DSL. Es wird versucht die Daten durch eine
  tabellarische Struktur übersichtlich zu gestalten. Die Syntax der Sprache ist sehr schlicht und ausdrucksstark. Ein Label
  vor einer Tabelle drückt aus, welche Daten folgen (Zeilen 1 und 6). Die Tabelle selbst beginnt mit einer Kopfzeile,
  die die Spaltenreihenfolge beschreibt (Zeilen 2 und 7). Einzelne Spalten werden vom Oder-Operator (|) getrennt. Die
  erste Spalte nimmt Zeilen-Identifikatoren auf und ist von den Daten mit Hilfe des Double-Pipe-Operators (||) abgrenzt.

  \lstSetTiny
  \begin{lstlisting}[caption=Mögliche DSL (3), label=listing:dslentwurf3]
professor:
REF    || name    | vorname  | titel            | fakultaet    | leitet          | beaufsichtigt
HAASE  || "Haase" | "Oliver" | "Prof. Dr."      | "Informatik" | VSYS, DPATTERNS | P_DPATTERNS   
WAESCH || "Wäsch" | "Jürgen" | "Prof. Dr.-Ing." | "Informatik" |                 | P_VSYS
  
lehrveranstaltung:
REF       || name                | sws | ects
VSYS      || "Verteilte Systeme" | 4   | 5
DPATTERNS || "Design Patterns"   | 4   | 3

...
  \end{lstlisting}
  \lstSetNormal
  
  Der Entwurf sieht vor, dass Beziehungen innerhalb beider Entitätstypen ausgedrückt werden können. So kann
  eine Tabelle um Spalten für Beziehungen ergänzt werden, die in dieser Form nicht Teil des relationalen
  Modells (\refimg{img:example_relational}) sind. Dazu gehören die Spalten "`leitet"' und "`beaufsichtigt"'
  der Professor-Tabelle. Erstere drückt die 1:n-Beziehung zu einer Lehrveranstaltung aus, letztere die
  m:n-Beziehung zu Prüfungen.
  
  Probleme bzw. Nachteile in der Darstellung können auftreten, wenn die Länge der Werte in einer Spalte stark
  variiert. Die Spaltenbreite wird vom längsten Element bestimmt. Der Entwickler ist selbst dafür verantwortlich,
  die übersichtliche Darstellung einzuhalten. Auf Tabulatoren sollte unter  Umständen verzichtet werden, da sie von
  verschiedenen Editoren unterschiedlich dargestellt werden können. Bei vielen Spalten wächst diese Darstellung
  horizontal. Bei optionalen Spalten bzw. kaum genutzte Spalten kann die tabellarische Darstellung unübersichtlich
  werden.
  
  Einige Entwicklungsumgebungen wie Eclipse bieten spezielle Block-Bearbeitungsfunktionen an, die beim Arbeiten an
  einer Tabellen-DSL hilfreich sein kann. So können beispielsweise in einer Spalte über mehrere Zeilen hinweg 
  Leerzeichen eingefügt oder entfernt werden.
  
  Bei umfangreichen Tabellen, die möglicherweise nicht mehr auf eine Bildschirmseite passen, kann es sinnvoll sein,
  den Tabellenkopf zu wiederholen. Dies sollte von der Implementierung genauso unterstützt werden wie die Definition
  neuer Tabellenköpfe mit unterschiedlichen Spalten.
  
  \subsection{Finaler DSL-Entwurf}

  Der dritte Entwurf zeigt, dass eine tabellarische Schreibweise viele Schwächen der anderen Varianten ausmerzt.
  Die Darstellung wirkt übersichtlich, da sie wenig syntaktischen Ballast hat. Es können schnell viele Daten
  überblickt werden. Die tabellarische Schreibweise sollte für die Zielgruppe vertraut wirken und intuitiver
  sein als die anderen Darstellungsformen.
  
  Darüber hinaus soll es möglich sein, Beziehungen auch außerhalb der Tabellen zu beschreiben. Dafür wäre eine Syntax
  denkbar, die sich an die Modellierung der Beziehungen aus Entwurf 1 orientiert (siehe Listing \ref{listing:dslentwurf1}).
  
  Der finale Entwurf stellt eine Kombination aus der tabellarischen Syntax von Entwurf 3 und der Modellierung der
  Beziehungen aus Entwurf 1 dar.
  

\section{Wahl der Technologie}
\label{sec:modellierung:wahlimplementierung}

Die DSL soll sich in die bisherige Werkzeugkette von SEITENBAU integrieren lassen 
(\refsec{sec:anforderungen:allgemeineanforderungen}). In \cite[148]{DSLS_IN_ACTION}
empfiehlt Ghosh die Programmiersprache Groovy als Host für DSLs in Verbindung mit Java-Anwendungen. 

Groovy ist eine dynamisch typisierte Sprache\footnote{Im Gegensatz zu statisch 
typisierten Sprachen finden bei dynamisch typisierten Typ-Überprüfungen überwiegend zur Laufzeit statt.}, die
direkt in Java-Bytecode übersetzt wird und damit auch in einer Java Virtual Machine (JVM) ausgeführt wird.
Dies ermöglicht die Nutzung von Groovy-Klassen und Groovy-Objekten in Java und umgekehrt.

Java-Code ist bis auf wenige Ausnahmen gültiger Groovy-Code. Allerdings bietet Groovy Möglichkeiten, Code
von sogenanntem syntaktischem Ballast zu befreien. Beispielsweise können Semikolons am Ende einer Anweisung
meistens weggelassen werden. Der Punkt zwischen einer Variable und der Methode ist unter gewissen Bedingungen
ebenfalls optional. Häufig kann auch auf die Klammerung von Methodenparametern verzichtet werden.
werden. Auf diese Weise ermöglicht Groovy eine Syntax, die den Code mehr wie eine natürlichen Sprache 
aussehen lässt.

Listing \ref{listing:groovyexamples} zeigt die selben Anweisungen einmal in typischer Java-Syntax (Zeile 1)
und einmal mit den Syntax-Vereinfachungen von Groovy (Zeile 2):

  \begin{lstlisting}[caption=Vereinfachung von Ausdrücken in Groovy, label=listing:groovyexamples]
take(coffee).with(sugar, milk).and(liquor);
take coffee  with sugar, milk  and liquor
  \end{lstlisting}

Groovy hebt sich ferner durch die Möglichkeit Operatoren zu überladen und durch Closures von Java ab. Ein Closure
(Funktionsabschluss) ist ein Codeblock, der wie eine Funktion aufgerufen und genutzt werden kann. In Java lassen
sich Closures mit syntaktisch umfangreicheren Methoden-Objekten nachbilden. Ein Methoden-Objekt stellt eine
Instanz einer (möglicherweise anonymen) Klasse dar, die nur eine Methode implementiert. \cite[40]{GROOVY_IM_EINSATZ} 
\todo{Quelle Kent Beck Smalltalk Best Practice Patterns} 

Die Unterstützung zur Meta-Programmierung stellt sich beim Implementieren einer DSL ebenfalls als nützlich
heraus. Dadurch ist es z.B. möglich, abgeschlossene Klassen innerhalb von Groovy um Methoden zu erweitern oder auf
den Zugriff von nicht definierten Klassenelementen zu reagieren.


  \subsection{Implementierungsvarianten mit Groovy}
  \label{sec:modellierung:implementierung:varianten}
  
  Eine DSL kann auf unterschiedliche Arten implementiert werden. Groovy bietet dafür zwei Möglichkeiten der
  Meta-Programmierung an: Laufzeit-Meta-Programmierung und Compiler-Zeit-Meta-Programmierung, letzteres in Form von
  AST-Transformationen. Beide Ansätze bieten individuelle Vorteile, die im folgenden diskutiert werden.  
  \nomenclature{AST}{Abstract Syntax Tree}


    \subsubsection{Laufzeit-Meta-Programmierung}
    \label{sec:modellierung:implementierung:varianten:laufzeit}
    
    Eine Möglichkeit, die DSL mit Hilfe von Laufzeit-Meta-Programmierung zu implementieren sieht eine 
    Klasse zum Parsen von Closures vor, die eine Tabelle beinhalten. Diese Klasse, \texttt{TableParser},
    enthält dafür die Methode \texttt{parseTableClosure}. Die Methode soll als Ergebnis eine Liste
    von Tabellenzeilen zurückliefern. Da an dieser Stelle noch keinerlei Interpretation der Tabellenwerte
    durchgeführt wird, stellt eine Tabellenzeile selbst ebenfalls eine Liste dar -- aus den Objekten
    der Spalten.
    
    Der Ansatz ist, Operator-Überladen für das Parsen zu verwenden. Soll ein binärer Operator implementiert
    werden, ist die übliche Vorgehensweise in Groovy, die Klasse des linken Operanden um eine entsprechende
    Methode für den Operator zu erweitern. Diese Methode trägt einen vorgegebenen Namen und erwartet als
    binärer Operator  den rechten Operanden als Parameter (eine Übersicht findet sich beispielsweise in 
    \cite[58]{GROOVY_IM_EINSATZ}).
    
    Auch wenn sich dank der Möglichkeiten der Meta-Programmierung Klassen in Groovy zur Laufzeit um Methoden
    ergänzen lassen, ist dieses Vorgehen nicht empfehlenswert um eine Tabelle zu parsen. Dieser wenig
    generische Ansatz müsste jeden in den Tabellen mögliche Datentyp berücksichtigen -- kommen neue Datentypen
    hinzu, müsste der Code erweitert werden. Schlimmer wiegt jedoch, dass diese Anpassungen global
    für die entsprechenden Klassen gelten. Das könnte ungewollte Seiteneffekte nach sich ziehen, wenn 
    Oder-Operatoren auch an anderer Stelle verwendet werden, wie z.B. zum Berechnen eines Spalten-Wertes.
    
    Groovy bietet allerdings auch eine zweite Möglichkeit für das Operator-Überladen an. Anstatt den Operator
    als Methode dem linken Operand (bzw. der Klasse) hinzuzufügen, wird er als statische Methode (in einer
    beliebigen Klasse) realisiert. Da eine statische Methode ohne Kontext ausgeführt wird, benötigt sie alle
    beteiligten Operanden als Parameter. Eine solche Methode wird als Kategoriemethode bezeichnet. 
    Über das Schlüsselwort \texttt{use}\footnote{\texttt{use} wird in der Literatur meistens als Schlüsselwort
    bezeichnet, tatsächlich handelt es sich jedoch um eine Groovy-Methode in \texttt{java.lang.Object}}
    können die Kategoriemethoden in einem Closure verwendet werden. \cite[192]{GROOVY_IM_EINSATZ} 
    
    Listing \ref{listing:opoverloading.tableparser.base} zeigt das Grundgerüst des Tabellenparsers:
    
    \begin{lstlisting}[caption=Tabellen-Parser Grundgerüst mit Operator-Überladen, label=listing:opoverloading.tableparser.base]
class TableParser {
  
  static or(Object self, Object arg) {
    ...
  }

  def parseTableClosure(Closure tableData){
    use(TableParser) {
      tableData()
    }
  }

}
    \end{lstlisting}
    
    Die Methode \texttt{or} erwartet zwei Parameter vom Typ \texttt{Object}. Obwohl in Groovy alle Typen von
    \texttt{Object} abgeleitet sind, gibt es Oder-Ausdrücke, bei denen diese Methode nicht aufgerufen wird.
    Ein in der Klasse definierter Operator mit passenden Datentypen wird dieser allgemeinen Methode bevorzugt,
    z.B. bei zwei \texttt{Integer}-Werten. Doch auch solche Operationen lassen sich überschreiben, wenn für
    die Datentypen passende Kategoriemethoden definiert werden. Diese und weitere Anpassungen sind in Listing 
    \ref{listing:opoverloading.tableparser.extended} dargestellt.
    
    Im zu parsenden Closure sollen Variablen genutzt werden, die nicht im Closure selbst sondern in einer anderen Klasse
    definiert werden. Zu diesen Variablen gehören die Bezeichner der Spalten und die der Zeilen. Groovy erlaubt es Closures im
    Kontext eines Delegaten auszuführen. In diesem Beispiel wird die aktuelle Instanz der Klasse \texttt{TableParser} verwendet 
    (Zeile 22). Dieser Delegat wird bei der Auflösung von Variablen- und Methoden-Bezeichern verwendet. In Zeile 23 wird 
    festgelegt, dass bei der Auflösung zuerst im Delegaten gesucht wird.
    
    In diesem Prototyp sind keine Variablen für Spalten oder Zeilen definiert. Folglich schlägt das Auflösen fehl.
    Groovy ruft Groovy dann die Methode \texttt{propertyMissing} in der jeweiligen Klasse auf. Eine Property ist 
    eine Variable oder eine parameterlose Get-Methode. Eine solche Get-Methode
    kann in Groovy wie eine Variable genutzt werden, wenn auf das Präfix \texttt{get} und die Klammern verzichtet wird.
    Durch Überschreiben dieser Methode kann auf nicht auflösbare Bezeichner reagiert werden.

    \begin{lstlisting}[caption=Tabellen-Parser Grundgerüst mit Operator-Überladen, label=listing:opoverloading.tableparser.extended]
class TableParser {
  
  static or(Object self, Object arg) {
    ...
  }
  
  static or(Integer self, Integer arg) {
    ...
  }

  static or(Boolean self, Boolean arg) {
    ...
  }
  
  def propertyMissing(String property) {
    ...
  }
  

  def parseTableClosure(Closure tableData){
    use(TableParser) {
      tableData.delegate = this    // Change closure's context
      tableData.resolveStrategy = Closure.DELEGATE_FIRST
      tableData()
    }
  }

}
    \end{lstlisting}
    
    Die statischen Methoden haben keinen Zugriff auf Instanz-Variablen der Klasse \texttt{TableParser}. Ihre Ergebnisse
    können sie demnach auch nur in statische Elementen aufbewahren. Um die Klasse Thread-sicher zu machen, d.h. das
    Erlauben von gleichzeitigem Parsen von Tabellen aus verschiedenen Threads heraus, wird für die Ergebnisse eine 
    threadlokale Liste verwendet. \cite[45]{JAVA_CONCURRENCY_IN_PRACTICE}

    Die Laufzeit-Meta-Programmierung kann die Syntax der Sprache nicht beliebig erweitern. Groovy kennt keinen
    Double-Pipe-Operator. Deshalb kann dieser weder überladen noch über Laufzeit-Meta-Programmierung eingeführt
    werden. Folglich ist es nicht möglich, den dritten Entwurf über reine Laufzeit-Meta-Programmierung zu
    realisieren. Allerdings kann eine Syntax erreicht werden, die dem Entwurf sehr nahe kommt
    (\reflst{listing:dslentwurf3laufzeit}). Das DataSet wird als Map definiert, mit den Tabellennamen als
    Schlüsseln und Closures als Werte. Ein Platzhalter (Unterstrich) verhindert Syntax-Fehler, wenn in
    einer Spalte kein Wert vorkommt (siehe Zeile 4, Spalte "`leitet"'). Der Platzhalter könnte auch verwendet
    werden, um einem Datensatz keinen Bezeichner für Referenzen zu zu weisen. Aus Sicht des Parsers stellt
    der Unterstrich eine Variable dar.
    
    \lstSetTiny
    \begin{lstlisting}[caption=DSL-Entwurf 3 für Laufzeit-Meta-Programmierung angepasst, label=listing:dslentwurf3laufzeit]
def dataset = [
  professor: {
    REF    | name    | vorname  | titel            | fakultaet    | leitet           | beaufsichtigt
    WAESCH | "Wäsch" | "Jürgen" | "Prof. Dr.-Ing." | "Informatik" | _                | P_VSYS
    HAASE  | "Haase" | "Oliver" | "Prof. Dr."      | "Informatik" | VSYS & DPATTERNS | P_DPATTERNS
  },

  lehrveranstaltung: {
    REF       | name                | sws | ects
    VSYS      | "Verteilte Systeme" | 4   | 5    
    DPATTERNS | "Design Patterns"   | 4   | 3    
  },
    
  ...
]    
    \end{lstlisting}
    \lstSetNormal
    
    

    \subsubsection{AST-Transformation}
    
    Die AST-Transformationen stellen ein mächtiges Werkzeug zur Erweiterung der Syntax der Sprache dar. Mit Hilfe
    der Transformationen ist es möglich, Änderungen am AST durchzuführen, bevor er in Java-Bytecode übersetzt wird.
    
    Dass AST-Transformationen mehr syntaktische Möglichkeiten bieten, zeigt sich auch daran, dass hier der 
    Double-Pipe-Operator verwendet werden kann. Außerdem können Labels erkannt werden und Daten einer Tabelle
    müssen nicht zwangsläufig in einem eigenen Block definiert werden.
    
    Allerdings muss zum Auswerten einer Tabelle bei AST-Transformationen ein relativ großer Aufwand betrieben werden.
    Ein AST-Transformationsklasse, erhält über das Visitor-Pattern Zugriff auf die abstrakten Syntaxbäume einzelner
    Module (\cite[331ff]{DESIGN_PATTERNS}). Groovy Module beinhalten Klassen, aber auch die modulspezifischen
    Import-Anweisungen. Auf die einzelnen Klassen kann erneut über das Visitor-Pattern auf die einzelnen Methoden
    zugegriffen werden. Diese lassen sich dann Statement für Statement untersuchen.
    
    Für das Parsen interessante Statements sind von den Typ \texttt{ExpressionStatement}. Es kann abgefragt werden,
    ob ein Label Teil des Statements ist. Über ein solches Label können die Daten den einzelnen Tabellen zugeordnet
    werden. Das eigentliche \texttt{ExpressionStatement} kann danach analysiert werden. Die folgenden drei Arten von
    Ausdrücken sind relevant für das Parsen:
    
    \begin{itemize}
      \item \textbf{\texttt{BinaryExpression}}: Ein binärer Ausdruck besteht aus zwei Operanden und einem Operator.
        Wenn es sich beim Operator um einen Pipe oder Double-Pipe-Operator handelt, werden die linken und rechten
        Operanden, die selbst vom Typ \texttt{ExpressionStatement} sind, rekursiv behandelt.
        
      \item \textbf{\texttt{ConstantExpression}}: Konstante Ausdrücke sind Literale, die als Spaltenwert verwendet werden.
      
      
      \item \textbf{\texttt{VariableExpression}}: Ein Bezeichner einer Variablen. Dazu gehören die 
        Spalten-Bezeichner und die Bezeichner für die einzelnen Zeilen.
    \end{itemize}
    
    Insgesamt muss viel Aufwand betrieben werden, um den AST zu analysieren. Möglicherweise kann durch die Nutzung
    von sogenannten DSL Descriptoren für die Groovy-Plugins gängiger IDEs auch eine IDE-Unterstützung für Labels
    und Spalten erreicht werden. Dieser Frage wird allerdings im weiteren Verlauf nicht nachgegangen.
    
    
  \subsection{Implementierungsentscheidung}
  \label{sec:implementierung:entscheidung}
  
  Der Vergleich zwischen Laufzeit-Meta-Programmierung und AST-Transformation zeigt, dass sich Groovy als Host-Sprache
  für die DSL eignet. Grundsätzlich kann das Parsen der Tabelle über beide Varianten durchgeführt werden und beide
  Varianten erfüllen die Anforderungen.
  
  Die Entscheidung fällt auf die Laufzeit-Meta-Programmierung. Der Grund dafür ist, dass sie einfacher zu verwenden ist. 
  AST-Transformationen würden bezogen auf die Anforderungen keinen Mehrwert bieten. Darüber hinaus dürfte der Code zur
  AST-Transformation komplexer und wartungsunfreundlicher ausfallen.

\section{Definition der Sprache}
\label{sec:implementierung:sprachdefinition}

Die Entscheidung zugunsten der Laufzeit-Meta-Programmierung führt zu einigen Änderungen an der Sprache aus dem dritten
Entwurf (siehe Abschnitt \ref{sec:implementierung:entwurf:3}). Wie beschrieben, wird auf den Double-Pipe-Operator
verzichtet. Anstelle der Labels treten vordefinierte Variablen, deren Namen sich nach jeweiligen Tabellenbezeichnungen 
richten. Auf diesen Variablen kann zum Definieren von Tabellendaten die Methode \texttt{rows} aufgerufen werden.
Die Daten werden in Form eines Closures übergeben. 

Zur Übersicht sollen einzelne DataSets als eigene Klassen definiert werden, die auf einer Datenbank-Modell-spezifischen
abstrakten Klasse basiert. Für die Definition der Tabellen-Daten ist die Methode \texttt{tables} vorgesehen, über die
DSL ausgedrückte Beziehungen sollen innerhalb der Methode \texttt{relations} modelliert werden.

Die Syntax für die Definition der Daten einer Tabelle wird mit Hilfe der Erweiterten Backus-Naur-Form in
Listing \ref{listing:ebnf:table} definiert.
  
\lstSetEBNF
\begin{lstlisting}[caption=EBNF der Tabellen, label=listing:ebnf:table]
Table       = TableName, "Table.rows ", TableData;
TableName   = ? Name einer Tabelle im Modell ?;
TableData   = {", NewLine, { HeadRow, { DataRow } }, NewLine, "}";
HeadRow     = ColumnName, { Separator, ColumnName }, NewLine;
DataRow     = ColumnData, { Separator, ColumnData }, NewLine;
ColumnName  = ? vorgegeben durch Tabelle ?;
ColumnData  = ? numerische Literale, symbolische Konstanten, 
              Methodenaufrufe ?;
Separator   = "|";
NewLine     = "\n";
\end{lstlisting}
\lstSetJava

\lstSetEBNF
\begin{lstlisting}[caption=EBNF der Relationen, label=listing:ebnf:relations]
Relations   = { Relation, NewLine };
Relation    = Ref, ".", RelationName, "(", RefList, ")", [ Attributes ];
RefList     = Ref, [ { ", ", Ref } ];
Ref         = ? Bezeichner einer Ref-Variable ?;
Attributes  = { ".", Attribute, "(", Value, ")" };
Attribute   = ? Von Beziehung abhängiger Attribut-Bezeichner ?;
Value       = ? numerische Literale, symbolische Konstanten, 
              Methodenaufrufe ?;
NewLine     = "\n";
\end{lstlisting}
\lstSetJava


\section{Beispiel-DataSet in Groovy}
\label{sec:modellierung:beispieldataset}

In Kapitel \ref{chap:anforderungen} wurden Beispiel-Daten in unterschiedlichen Verfahren modelliert. Aufgrund der Übersicht
wurden dort nur jeweils zwei Tabellen dargestellt. Listing \ref{listing:hochschuledataset:table} zeigt, wie sich die selben
Daten mit der neuen DSL modellieren lassen -- diesmal allerdings in vollem Umfang.
  
\begin{lstlisting}[caption=DataSet modelliert mit Table Builder API, label=listing:hochschuledataset:table]
class HochschuleDataSet extends HochschuleBuilder
{

  def tables() {

    professorTable.rows {
      REF    | name    | vorname  | titel            | fakultaet
      WAESCH | "Wäsch" | "Jürgen" | "Prof. Dr.-Ing." | "Informatik"
      HAASE  | "Haase" | "Oliver" | "Prof. Dr."      | "Informatik"
    }

    lehrveranstaltungTable.rows {
      REF       | name                | sws | ects
      VSYS      | "Verteilte Systeme" | 4   | 5
      DPATTERNS | "Design Patterns"   | 4   | 3
    }

    pruefungTable.rows {
      REF         | typ   | zeitpunkt
      P_VSYS      | "K90" | DateUtil.getDate(2013, 4, 1, 14, 0, 0)
      P_DPATTERNS | "M30" | DateUtil.getDate(2013, 1, 6, 12, 0, 0)
    }

    studentTable.rows {
      REF        | matrikelnummer | name         | vorname    | studiengang
      MUSTERMANN | 123456         | "Mustermann" | "Max"      | "BIT"      
      MOLL       | 287336         | "Moll"       | "Nikolaus" | "MSI"      
  
      REF        | semester | immatrikuliert_seit
      MUSTERMANN | 3        | DateUtil.getDate(2012, 3, 1)
      MOLL       | 4        | DateUtil.getDate(2011, 9, 1)
    }

  }

  def relations() {
    WAESCH.beaufsichtigt(P_VSYS)
    HAASE.leitet(VSYS, DPATTERNS)
    HAASE.beaufsichtigt(P_DPATTERNS)
    P_VSYS.stoffVon(VSYS)
    DPATTERNS.hatPruefung(P_DPATTERNS)
    MOLL.schreibt(P_VSYS)
    MOLL.besucht(VSYS)
    VSYS.hatTutor(MOLL)
    MUSTERMANN.besucht(DPATTERNS)
  }

}
\end{lstlisting}



Insgesamt ist die Darstellung sehr übersichtlich. Der Code wurde aufgrund der eingeschränkten Seitenbreite leicht
angepasst und die Tabelle mit den Studenten in zwei Blöcke aufgeteilt (Zeilen 24 bis 32). In diesem Beispiel ist
diese Darstellung eher unüblich, aber der Parser unterstützt auch die Definition von Teiltabellen mit
unterschiedlichen Spalten innerhalb eines Closures.

Innerhalb der Methode \texttt{tables} werden die Daten der einzelnen Tabellen auf Datenbank-Ebene modelliert.
Die Methode \texttt{relations} erlaubt die Modellierung von Beziehungen auf der höheren ER-Ebene. Sogar Beziehungen,
die über assoziative Tabellen realisiert werden, können so modelliert werden.

Alternativ könnten Beziehungen auch auf der Datenbank-Ebene modelliert werden. Listing 
\ref{listing:hochschuledataset:tablerelations} veranschaulicht diese Variante.

\begin{lstlisting}[caption=Beziehungen innerhalb von Tabellen, label=listing:hochschuledataset:tablerelations]
class HochschuleDataSet extends HochschuleBuilder
{

  def tables() {
    
    ...
		
    lehrveranstaltungTable.rows {
      REF       | professor
      VSYS      | HAASE
      DPATTERNS | HAASE
    }
    
    beaufsichtigtTable.rows {
      professor | pruefung
      WAESCH    | P_VSYS
      HAASE     | DPATTERNS
    }

  }
  
  ...
  
}
\end{lstlisting}
