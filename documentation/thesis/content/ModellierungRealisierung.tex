\chapter{Realisierung der Sprache}
\label{chap:realiserungdsl}

Das folgende Kapitel beschreibt die Implementierung der in Kapitel \ref{chap:modellierung} entwickelten Sprache.
\textit{STU} stellt die Basis für Erweiterungen und Verbesserung dar. Es verfolgt bereits das Ziel, Tests von
Datenbank-basierten Anwendungen zu erleichtern und vereinfacht die Modellierung von DbUnit-DataSets. Auf Abwärtskompatibilität
wird wenn notwendig zu Gunsten der Benutzbarkeit und Wartbarkeit verzichtet.

Aus einem domänenspezifischen Datenbank-Modell erzeugt \textit{STU} ein individuelles API zur Modellierung von DataSets.
Um die Modellierung zu vereinfachen, vor allem in Bezug auf die Beziehungen, sollen die generierten Klassen um eine Fassade
ergänzt werden. 

Eine Möglichkeit, eine solche Fassade zu realisieren, stellen domänenspezifische Sprachen dar. Eine domänenspezifische
Sprache zeichnet sich dadurch aus, dass sie für ein spezielles Problemfeld entworfen wurde. Martin Fowler erklärt in
\cite[xix]{DOMAIN_SPECIFIC_LANGUAGES}, dass die meisten domänenspezifischen Sprachen lediglich eine dünne Fassade über
einer Bibliothek oder einem Framework sind.

Der Code-Generator aus \textit{STU} erzeugt zwei APIs für die Modellierung von DataSets:
\begin{itemize}
  \item Das \textbf{Fluent Builder API} ist ein \textbf{Java}-basiertes API. Der Name spiegelt wider, dass es ein Java
    Fluent API bereit stellt (siehe auch Abschnitt \ref{sec:grundlagen:stu}). Ein solches API wird auch als
    interne DSL bezeichnet.
      
  \item Das \textbf{Table Builder API} ist das \textbf{Groovy}-basierte API bzw. die neue DSL. Über diese DSL können
    die Testdaten tabellarisch modelliert werden.
      
\end{itemize}

Abbildung \ref{img:architektur} stellt die Architektur eines Tests grafisch dar. Der Test basiert auf 
einem Test-Framework wie \textit{JUnit}, der Testbibliothek \textit{STU} und der Bibliothek \textit{DbUnit}.
\textit{STU} setzt sich aus den beiden oben genannten Schichten zusammen.

\begin{figure}[htbp]
  \centering
   \includegraphics[scale=1]{images/realisierung/stu_architektur.png}
  \caption{Architektur}\label{img:architektur}
\end{figure}

Das neue Table Builder API stellt eine Schicht über dem bisherigen Fluent Builder API dar. Neue Funktionen müssen 
jedoch nicht zwangsläufig im Table Builder API hinzugefügt werden, unter Umständen kann es vorteilhaft sein, sie
direkt in das Fluent Builder API zu integrieren. Gründe dafür sind unter anderem:
\begin{itemize}
  \item \textbf{Code-Qualität}: Die neuen Funktionen können direkt in bestehende Klassen integriert werden, anstatt
    neue Typen einzuführen. Auf Adapter-Klassen und Delegation kann auf diese Weise verzichtet werden. Das erleichtert
		die Pflege der Implementierung und vermeidet redundanten Code.
      
  \item \textbf{Mehrwert auch für bisheriges API}: Auch wenn auf das neue Table Builder API verzichtet wird,
    kann das Builder API so einen Mehrwert gegenüber der bisherigen \textit{STU}-Implementierung bieten.
		Verbesserungen im Fluent Builder API sind auch in reinen Java-basierten Tests nutzbar.
      
  \item \textbf{Einheitlicher Funktionsumfang}: Das Table Builder API und das Fluent Builder API sollen -- so weit
	  möglich und sinnvoll -- denselben Funktionsumfang bieten. Erweiterungen für das Fluent Builder API stehen
		automatisch auch im Table Builder API zur Verfügung.

\end{itemize}




\section{Änderungen am Generator-Modell}
\label{sec:modellierung:generatormodell}

  Die hinzugekommenen Funktionen erfordern Erweiterungen in den Klassen zur Modellierung der zugrunde liegenden Datenbank.
  Das bisherige API in \textit{STU} nutzt überladene Methoden mit vielen optionalen Parametern zur Beschreibung von Spalten.
	Dies ist weder wartungs- noch anwenderfreundlich. Jeder neue optionale Parameter würde die Anzahl der Methoden unter
	Umständen verdoppeln. Für Anwender ist es nicht immer einfach, sich die Reihenfolge langer Parameterlisten zu merken,
	v.a. wenn es mehrere Varianten derselben Methode gibt.
	
	Die Klassen zur Beschreibung des Generator-Modells werden deshalb auf das Builder-Pattern umgestellt. Dieses löst beide
	Probleme. Jeder zusätzliche optionale Parameter führt zu einer neuen Methode. Die Reihenfolge der Methodenaufrufe ist im
	Gegensatz zu Parameterlisten beliebig. Der Code liest und schreibt sich einfacher, da Parameter durch die Methodenaufrufe
	benannt sind.
  
  Die neuen Builder-Klassen decken den Funktionsumfang des alten API ab. Dabei werden Eigenschaften für Spalten nicht mehr über 
  ein \texttt{EnumSet} festgelegt, sondern über Methoden für die vordefinierten Flags. In Abschnitt 
  \ref{sec:modellierung:generatormodell:flags}  wird weiter auf das Thema Flags eingegangen. Darüber hinaus bieten die
  neuen Klassen die Möglichkeit, Beschreibungen zu Tabellen und Spalten hinzuzufügen. Diese werden bei der Code-Generierung
  für die Erstellung von JavaDoc-Kommentaren verwendet (\refsec{sec:ralisierungdsl:javadoc}).
  
	Erweiterungen am Generator-Modell betreffen vor allem die Modellierung von Beziehungen zwischen Tabellen. Der folgende Abschnitt
	beschreibt die Modellierungskonzepte für Beziehungen in Datenbanken.


  
  \subsection{Spalten-Eigenschaften}
  \label{sec:modellierung:generatormodell:flags}
  
	Meta-Informationen von Spalten beinhalten neben dem Namen der Spalte und dem Typ weitere Eigenschaften. Diese Eigenschaften
	werden in \textit{STU} mit Hilfe sogenannter Flags beschrieben. Die Flags sind bislang in einem \textit{Enum}
	zusammengefasst. Alle für eine Spalte gesetzten Flags müssen beim Hinzufügen einer Spalte über ein \textit{EnumSet}
  übergeben werden. Bei dem neuen Builder-API werden die Flags über spezielle Methoden gesetzt.
  
  Zu den in \textit{STU} enthaltenen Standard-Spalten-Flags gehören:
  \begin{itemize}
    \item \textbf{Identifier}: Dieses Flag gibt an, dass die Werte einer Spalte die Zeile eindeutig identifizieren. 
      Sollen Werte in einer Zeile abgefragt oder verändert werden, kann die Zeile mit Hilfe einer solchen Spalte 
      identifiziert werden.
       
      Da die Werte zur Identifikation verwendet werden, ist ein nachträgliches Ändern nicht erlaubt. Dies soll anhand eines
      kurzen Beispiels begründet werden (siehe Listing \ref{listing:beispielimmutable}). Es zeigt einen Ausschnitt einer
      Studenten-Tabelle. Die Spalten \texttt{id} und \texttt{matrikelnummer} sind mit dem Flag \texttt{Identifier}
      versehen. In Zeile 2 werden Daten mit der ID 1 und der Matrikelnummer 123456 definiert. Zeile 3 steht für beliebige
      Anweisungen, in Zeile 4 und 5 wird die Studententabelle erweitert, z.B. innerhalb eines Unit-Tests. Zeile 5
      definiert Daten mit der ID 2 und der vorherigen Matrikelnummer. Beziehen sich beide Zeilen auf 
      denselben Studenten und die ID soll verändert werden? Oder wurde die Matrikelnummer irrtümlich falsch angegeben?
      Die ID des Studenten Mustermann auf 2 zu ändern, könnte zu Problemen führen, da nicht bekannt ist, an welchen Stellen
      bereits auf ID 1 Bezug genommen wird.
      
      \begin{lstlisting}[caption=Beispiel für unveränderliche Identifikatoren, label=listing:beispielimmutable]
id | matrikelnummer | Name      
1  | 123456         | "Mustermann" 
...
id | matrikelnummer | vorname 
2  | 123456         | "Nikolaus"       
      \end{lstlisting}
      
      
      Das Flag wird über die Methode \texttt{identifier()} gesetzt, dabei wird das Flag \texttt{Immutable} implizit aktiviert.

    \item \textbf{Default Identifier}: Dieses Flag stellt eine Art Erweiterung für das Flag \texttt{Identifier} dar. Die mit
      diesem Flag markierte Spalte wird für Foreign-Key-Beziehungen auf die Tabelle verwendet, sofern nicht explizit eine
      andere Spalte angegeben wird. Die Methode zum Setzen des Flags ist \texttt{defaultIdentifier()}, die Flags \texttt{Identifier}
      und \texttt{Immutable} werden automatisch aktiviert.
      
    \item \textbf{Add Next Method}: \textit{STU} bietet die Möglichkeit, Werte-Generatoren 
      zu verwenden, um einen Spaltenwert manuell oder auch automatisch mit einem generierten Wert zu belegen. Aufgerufen wird der 
      Generator über eine sogenannte Next-Value-Methode auf dem RowBuilder. Ihr Name setzt sich aus dem Präfix \texttt{next} und dem
      Spaltennamen zusammen. Der Generator erzeugt für die jeweilige Spalte allerdings nur dann eine Next-Value-Methode, wenn das
      entsprechende Flag über \texttt{addNextMethod()} aus dem Builder-API gesetzt wurde. Standardmäßig muss die Next-Value-Methode
      manuell aufgerufen werden, über ein Flag kann dies auch automatisch erfolgen.
      
    \item \textbf{Auto Invoke Next}: Ist dieses Flag aktiviert, wird die Next-Value-Methode beim 
      Anlegen einer neuen Tabellenzeile automatisch aufgerufen. Beim Setzen des Flags über die Builder-Methode
      \texttt{autoInvokeNext()} wird automatisch auch das Flag zum Generieren der Next-Value-Methode gesetzt. 
    
    \item \textbf{Immutable}: Ist dieses Flag gesetzt, kann ein Wert in einer Spalte nur ein Mal gesetzt und danach
      nicht mehr verändert werden. Wenn das Flag zum automatischen Aufruf der Next-Value-Methode aktiviert ist, kann der
      automatisch erzeugte Wert allerdings überschrieben werden. Die Methode zum
      Aktivieren des Flags heißt \texttt{immutable()}.
      
    %\item \textbf{Auto Increment}: ... DBUNIT-Flag ... implizit addNextMethod
      
  \end{itemize}


  
  \subsection{Modellierung von Relationen über Builder-Klassen}
  \label{sec:modellierung:generatormodell:relationen}
  
  Das API zur Modellierung des Datenbankschemas als Grundlage für den Generator stellt eine der größten Veränderungen
	in der Implementierung dar. Die größten Änderungen betreffen  die Definition von Beziehungen zwischen Tabellen.
	Über \texttt{reference} kann der Builder zur Beschreibung der Relation aufgerufen werden. Die Beschreibung findet
	in zwei Bereichen statt:
  
  \begin{itemize}
    \item \textbf{local}: Der als \texttt{local} bezeichnete Teil beschreibt die Beziehung aus Sicht der Tabelle,
      in der sich die Spalte befindet. 
      
    \item \textbf{foreign}: Der \texttt{foreign}-Teil dient der Beschreibung der Beziehung aus Sicht der Tabelle,
      mit der die Beziehung hergestellt wird.
    
  \end{itemize}
  
  In beiden Bereichen kann ein Bezeichner angegeben werden. Dieser Bezeichner drückt die Beziehung in die
	jeweilige Richtung aus, in \textit{local} wird die Beziehung in Richtung \textit{foreign} bezeichnet. 
	Diese Bezeichner werden für die Methoden zur Modellierung der Beziehungen verwendet. Daneben können
	auch noch Beschreibungstexte angegeben werden, die für die JavaDoc genutzt werden.
  
  In Abschnitt \ref{sec:modellierung:generatormodell:buildervergleich} befindet sich ein Beispiel für die 
  Modellierung von Relationen.
  
  Durch die Nutzung des Builder-Patterns lassen sich weitere Attribute verhältnismäßig einfach hinzufügen, z.B.
  für die Generierung der Testdaten (siehe Kapitel \ref{chap:generieren}).
  
  
  \subsection{Alte und neue Builder-Klassen im Vergleich}
  \label{sec:modellierung:generatormodell:buildervergleich}
  
  Die Vorteile der Umstellung auf das Builder-Pattern sollen die beiden folgenden Listings veranschaulichen. Sie zeigen
  die Modellierung der Datenbank für den Generator. Der Übersicht halber wurde der Code auf die Anweisungen
  im Konstruktor der Modell-Klasse und die Definition von zwei Tabellen reduziert. Listing 
  \ref{listing:model:builder:old} zeigt die Modellierung im ursprünglichen \textit{STU}, während Listing
  \ref{listing:model:builder:new} die neuen Builder darstellt.
  
  \begin{lstlisting}[caption=Beispiel alte \textit{STU}-Builder, label=listing:model:builder:old]
database("Hochschule");
packageName("com.seitenbau.testing.dbunit.hochschule");

Table professoren = addTable("professor")
    .addColumn("id", DataType.BIGINT, Flags.AutoInvokeNextIdMethod) 
    .addColumn("name", DataType.VARCHAR)
    .addColumn("vorname", DataType.VARCHAR)
    .addColumn("titel", DataType.VARCHAR)
    .addColumn("fakultaet", DataType.VARCHAR);

Table lehrveranstaltungen = addTable("lehrveranstaltung")
    .addColumn("id", DataType.BIGINT, Flags.AutoInvokeNextIdMethod)
    .addColumn("professor_id", DataType.BIGINT, professoren.ref("id"))
    .addColumn("name", DataType.VARCHAR)
    .addColumn("sws", DataType.INTEGER)
    .addColumn("ects", DataType.DOUBLE);
  \end{lstlisting}
  
  In diesem Beispiel -- inkl. der nicht dargestellten Tabellen-Definitionen -- werden lediglich drei der
  insgesamt neun \texttt{addColumn}-Methoden verwendet.
  
  Die Codes zur Modellierung mit der alten und der neuen API ähneln sich, die Unterschiede liegen abgesehen
  von den Flags und Relationen eher im Detail. Listing \ref{listing:model:builder:new} zeigt die Modellierung
  derselben Tabellen mit dem neuen API. Die kürzeren Parameterlisten und die zusätzlichen Funktionen führen
  dazu, dass dieselben Modelle in \textit{STU} einige Zeilen länger werden. Dieser Nachteil wird durch
	die gewonnene Ausdrucksstäke mehr als ausgeglichen.
  
  \begin{lstlisting}[caption=Beispiel neue \textit{STU}-Builder, label=listing:model:builder:new]
database("Hochschule");
packageName("com.seitenbau.testing.dbunit.hochschule");

Table professoren = table("professor")
    .description("Die Tabelle mit den Professoren der Hochschule")
    .column("id", DataType.BIGINT) 
      .identifierColumn() 
      .autoInvokeNext()
    .column("name", DataType.VARCHAR)
    .column("vorname", DataType.VARCHAR)
    .column("titel", DataType.VARCHAR)
    .column("fakultaet", DataType.VARCHAR)
  .build();

Table lehrveranstaltungen = table("lehrveranstaltung")
    .description("Die Tabelle mit den Lehrveranstaltungen der Hochschule")
    .column("id", DataType.BIGINT)
      .identifierColumn() 
      .autoInvokeNext()
    .column("professor_id", DataType.BIGINT)
      .reference
        .local
          .name("geleitetVon")
          .description("Gibt an, von welchem Professor eine Lehrveranstaltung geleitet wird.")
        .foreign(professoren)
          .name("leitet")
          .description("Gibt an, welche Lehrveranstaltungen ein Professor leitet.")
    .column("name", DataType.VARCHAR)
    .column("sws", DataType.INTEGER)
    .column("ects", DataType.DOUBLE)
  .build();  
  \end{lstlisting}

    
	Bei der Modellierung von n:m-Beziehungen kann auf den \texttt{local}-Teil der Beziehung verzichtet werden.
	\textit{STU} verwendet automatisch den \texttt{foreign}-Teil der assoziierten Spalte. Anstelle der Methode
	\texttt{table} wird eine assoziative Tabelle mit der Methode \texttt{associativeTable} beschrieben. Listing
	\ref{listing:model:builder:assoc} zeigt ein Beispiel für die Modellierung einer assoziativen Tabelle:

  \begin{lstlisting}[caption=Beispiel für assoziative Tabelle, label=listing:model:builder:assoc]
associativeTable("besucht")
  .column("student_id", DataType.BIGINT)
    .reference
      .foreign(studenten)
        .name("besucht")
        .description("Die Lehrveranstaltungen, die ein Student besucht.")
  .column("lehrveranstaltung_id", DataType.BIGINT)
    .reference
      .foreign(lehrveranstaltungen)
        .name("besuchtVon")
        .description("Die Studenten, die eine Lehrveranstaltung besuchen.")
 .build();
  \end{lstlisting}



  \section{Neue DataSet-Builder-Klassen}
  \label{sec:realisierung:neuebuilder}
  
  Für die tabellarisch definierten DataSets wird eine neue Builder-Klasse generiert, die über Komposition und Delegation die
  bisherige, auf dem Fluent-Builder-API-basierende DataSet-Klasse nutzt.

  Der Großteil des IDE-Supports wird über Adapter-Klassen für die bisherigen Tabellen realisiert \cite[139]{DESIGN_PATTERNS}.
	Zu jeder Tabellen-Klasse wird
  eine zusätzliche Adapter-Klasse generiert. Dort sind die Tabellen-spezifischen Spaltenbezeichner für die tabellarische DSL
  definiert. Die Methode \texttt{rows} startet das Parsen der Tabellenzeilen, die wie im Entwurf als Closure übergeben werden.
  Innerhalb dieses Closures sind die in der Tabelle definierten Bezeichner nutzbar. Neben den Spaltenbezeichnern werden ein
  Spaltenbezeichner \texttt{REF} und auch der Platzhalter (Unterstrich) generiert. Die Adapter nutzen intern eine aggregierte
  Tabellen-Klasse. Dabei bildet der Adapter die Schnittstelle der Tabellen-Klasse nach und delegiert die Aufrufe.
  
  Jeder Spaltenbezeichner stellt eine anonyme Klasse dar, die die abstrakte Klasse \texttt{ColumnBinding} erweitert. Diese 
  enthält Meta-Informationen zu der zugehörigen Spalte und Methoden, die das Parsen der Tabellen erleichtern
  (siehe Abschnitt \ref{sec:ralisierungdsl:parser}). 

  Für jede Tabelle gibt es in der Builder-Klasse eine öffentliche Instanz der Adapter-Klasse. Auf diese Weise wird der
  IDE-Support bzgl. der Tabellennamen sichergestellt. Das Klassendiagramm ist in Abbildung \ref{img:builderarchitecture} dargestellt.

  \begin{figure}[htbp]
    \centering
     \includegraphics[width=0.6\textwidth]{images/realisierung/builderarchitecture.pdf}
    \caption{Klassendiagramm der DataSet-Builder}\label{img:builderarchitecture}
  \end{figure}
  
  
  



% http://martinfowler.com/eaaCatalog/gateway.html
% http://martinfowler.com/eaaCatalog/repository.html
% http://martinfowler.com/eaaCatalog/registry.html

    
  \section{Tabellenparser}
  \label{sec:ralisierungdsl:parser}
  
  Für den Parser wird der Code aus dem Prototyp genutzt (siehe Abschnitt \ref{sec:modellierung:implementierung:varianten:laufzeit}).
  Die Logik an sich ist relativ generisch, je nach konkreter Tabelle muss allerdings mit unterschiedlichen Datentypen
  gearbeitet werden. 
  
  Folgende zwei Möglichkeiten bieten sich an, den Parser zu realisieren:
  \begin{enumerate}
    \item Für jede Tabellen-Adapter-Klasse wird individueller Parser-Code generiert.
    \item Die Tabellen-Adapter nutzen eine generische Parser-Klasse.
  \end{enumerate}

  Die Generierung von redundantem Code scheint kein großer Nachteil zu sein. Gerade bei generiertem Code wird Redundanz weniger
  kritisch gesehen. Allerdings erreicht der Code zum Parsen einer Tabelle eine gewisse Komplexität, die die Pflege des Codes
  auf Template-Ebene erschwert. Die generische Klasse ist etwas aufwändiger zu implementieren, hat aber einige Vorteile: Die Wartung
  erfolgt IDE-unterstützt und Änderungen erfordern in der Regel keine Neu-Generierung der Tabellen-Klassen. Für die Tester
  ist der größte Vorteil jedoch, dass keine der zu generierenden Klassen spezielle Groovy-Features nutzen muss und es damit 
  ausreicht, Java-Klassen zu verwenden.
  
  Die Schwierigkeiten, die mit der Entscheidung zugunsten des generischen Parsers gelöst werden müssen, betreffen Operationen,
  die der Parser auf der Tabelle durchführen muss: Anlegen neuer Zeilen, Suchen nach Zeilen und Setzen von Werten auf den Zeilen.
  Dies wird unter anderem mit einem weiteren Adapter zwischen den bereits bekannten Table-Adapter-Klassen und dem generischen
  Table-Parser erreicht. Dieser Adapter implementiert das Interface \texttt{TableParserAdapter}. Die 
  Typ-Parameter enthalten Informationen zu den konkret verwendeten Klassen wie dem RowBuilder. Darüber hinaus bietet die Schnittstelle
  die benötigten Methoden zum Erstellen und Suchen von Tabellen-Zeilen.

  Das Setzen der Werte auf den RowBuildern ist deshalb ein Problem, weil die Bezeichner der Set-Methoden die Spaltennamen enthalten.
  Eine Lösung ist die bereits im letzten Abschnitt angesprochene \texttt{ColumnBinding}-Klasse. Sie definiert die abstrakte
  generische Methode \texttt{set(R row, Object value)}, wobei \texttt{R} der Typ-Parameter für den RowBuilder ist.
  In die Implementierungen der \texttt{set}-Methoden kann der korrekte Bezeichner für den jeweiligen Setter auf dem RowBuilder
  generiert werden.
  
	Mit automatischen Typumwandlungen bietet \texttt{STU} eine Komfortfunktion, die die Lesbarkeit weiter verbessert.
	Vom Parser eingelesene Werte werden nach Möglichkeit automatisch in den vom Modell erwarteten Datentyp konvertiert.
	Diese Konvertierung ist notwendig, da alle eingelesenen Werte als Objekte und nie als primitive Datentypen vorliegen.
	Beispielsweise konvertiert der Parser ein \texttt{Integer}-Wert in einer Spalte für \texttt{Double}-Werte in den
	passenden Typ. 
  
  \section{Referenzen und Scopes}
  \label{sec:ralisierungdsl:refs_and_scopes}
  
  Neben der Möglichkeit, Daten tabellarisch zu modellieren, gehören die neuen Referenz-Datentypen zu der wichtigsten Erweiterung.
  In \textit{STU} ist eine Referenz eine Art Stellvertreter für eine Entität (Tabellenzeile). Die Referenz kann bei der Modellierung 
  oder auch bei Such-Anfragen anstelle konkreter Werte (wie Primärschlüssel) verwendet werden. Die Such-Anfrage-Möglichkeiten
  werden in Abschnitt \ref{sec:ralisierungdsl:apierweiterungen} erläutert. Eine Referenzen werden im Folgenden auch als Ref bezeichnet.
  
  Referenzen müssen an ihre Datensätze gebunden werden. Im Table Builder API ist dafür die Spalte \texttt{REF} vorgesehen,
  die in jeder Tabelle genutzt werden kann, das Fluent Builder API bietet auf den RowBuilder-Klassen die Methode \texttt{bind()}.
  Die Listings \ref{listing:ref:bindingtable} und \ref{listing:ref:bindingfluent} zeigen die Modellierung derselben Zeile 
  einmal mit dem neuen Table Builder API und einmal mit dem erweiterten Fluent Builder API.
  
  \begin{lstlisting}[caption=Binden von Referenzen (Table Builder API), label=listing:ref:bindingtable]
professorTable.rows {
  REF    | name    | vorname  | titel            | fakultaet
  WAESCH | "Wäsch" | "Jürgen" | "Prof. Dr.-Ing." | "Informatik"
  ...
}
  \end{lstlisting}
  
  \begin{lstlisting}[caption=Binden von Referenzen (Fluent Builder API), label=listing:ref:bindingfluent]
table_Professor.insertRow()
  .bind(WAESCH)
  .setName("Wäsch")
  .setVorname("Jürgen")
  .setTitle("Prof. Dr.-Ing.")
  .setFakultaet("Informatik")
...
  \end{lstlisting}
  
  Da Referenzen die zugehörigen RowBuilder kennen, können ihre Werte auch direkt auf der Referenz abgefragt werden 
  (\reflst{listing:ref:valueaccess}).
  
  \begin{lstlisting}[caption=Zugriff auf Werte über Referenzen, label=listing:ref:valueaccess]
WAESCH.getName()    // Java style
WAESCH.name         // Groovy style
  \end{lstlisting}
  
  Darüber hinaus können über Referenzen Beziehungen modelliert werden. Sie enthalten Methoden zum Ausdrücken von Beziehungen.
  Die Methodennamen entsprechen den im Generator-Modell angegebenen Relationsnamen. Listing \ref{listing:ref:relations} zeigt
	anhand eines Beispiels, wie Beziehungen über Referenzen definiert werden.
	
  \begin{lstlisting}[caption=Definition von Beziehungen über Referenzen, label=listing:ref:relations]
WAESCH.beaufsichtigt(P_VSYS)
  \end{lstlisting}
  
  Die Referenzen müssen vor ihrer Nutzung definiert (deklariert und instantiiert) werden. Eine explizite Definition ist
	in Groovy nicht notwendig (siehe Abschnitt~\ref{sec:modellierung:implementierung:varianten:laufzeit}), ist aber 
	für die IDE-Unterstützung notwendig (z.B. für das Umbenennen von Referenzen, Erkennen von Tippfehlern bei Bezeichnern).
	Außerdem könnten sie auch nicht im normalen Java-Code verwendet werden. Es bietet sich an, Referenzen als globale Variablen zu
	definieren. Verschiedene DataSets (mit demselben Datenbank-Modell) können dieselben Referenzen nutzen, auch wenn sie
	unterschiedliche Werte repräsentieren.
  
  Damit dieselben Referenzen in unterschiedlichen DataSets genutzt werden können, werden die RowBuilder immer im Kontext des
  gerade aktiven DataSets gebunden. Das aktive DataSet wird über die \texttt{DataSetRegistry} festgelegt (und abgefragt). Pro
  Datenbank-Modell ist immer ein (oder kein) DataSet aktiv. Das heißt, wenn verschiedene Datenbank-Modelle genutzt werden,
  aus jedem Modell jeweils ein DataSet gleichzeitig aktiv sein kann.
  
  \section{Integration von DataSets in Unit-Tests}
  \label{sec:ralisierungdsl:junittest}
  
  Wie das Beispiel-DataSet aus Listing \ref{listing:hochschuledataset:table} in einem JUnit-Test verwendet werden kann,
  zeigt Listing \ref{listing:junittest}. Das System Under Test (siehe Abschnitt \ref{sec:grundlagen:konzepte:tests})
  ist ein Spring-Service, der von der Variable \texttt{sut} (Zeile 20) repräsentiert wird.
  
  Das in einem Test verwendete DataSet kann als Klasse über die Annotation \texttt{DatabaseSetup} konfiguriert werden
  (Zeile 26). Sie sorgt dafür, dass die angegebene DataSet-Klasse instantiiert und der Variable zugewiesen wird, die 
  mit der Annotation \texttt{InjectDataSet} markiert wurde (Zeilen 22 und 23). Außerdem wird dieses DataSet auch bei
  der \texttt{DataSetRegistry} als aktives DataSet registriert und die Daten in die Datenbank eingespielt. Dadurch
  kommen die Test-Methoden ohne Verwaltungsaufgaben aus. Der Test \texttt{removeStudent} testet, ob das System die
  richtigen Änderungen in der Datenbank vornimmt, wenn der Student \texttt{MUSTERMANN} entfernt wird. Da dem Service
  die zu löschende Entität übergeben werden muss (Zeile 38), wird in den Zeilen 29 bis 35 eine entsprechende Instanz
  erstellt und konfiguriert. 
  
  Der Test verwendet eine \texttt{DatabaseTesterRule} (Zeile 9), die unter anderem für die Vergleiche der Datenbank
  mit den DataSets verantwortlich ist. Dazu muss ihr die Datenbank bekannt sein, die in Form einer \texttt{DataSource}
  vorliegt (Zeile 6). Da dieses Feld durch \textit{Dependency Injection} (\cite[4]{PRO_SPRING}) erst
  nach der Instantiierung der Klasse belegt wird, kann bei der Erzeugung von \texttt{dbTester} der Wert noch nicht
  verwendet werden. Dies wird durch die Verwendung eines Future-Objekts gelöst, das die \texttt{DataSource} erst dann
  zurückliefert, wenn sie gebraucht wird (Zeilen 10 bis 15). 
  
  \begin{lstlisting}[caption=JUnit-Tests (reiner Java-Code), label=listing:junittest]
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes=HochschuleContext.class)
public class HochschuleDataSetDatabaseTest {

  @Autowired
  DataSource dataSource;

  @Rule
  public DatabaseTesterRule dbTester =
     new DatabaseTesterRule(new Future<DataSource>(){
       @Override
       public DataSource getFuture()
       {
         return dataSource;
       }
     }).addCleanAction(new ApacheDerbySequenceReset()
       .autoDerivateFromTablename("_SEQ"));

  @Autowired
  HochschuleService sut;

  @InjectDataSet
  HochschuleBuilder dataSet;

  @Test
  @DatabaseSetup(prepare = HochschuleDataSet.class)
  public void removeStudent() throws Exception {
    // prepare
    Student student = new Student();
    student.setMatrikelnummer(MUSTERMANN.getMatrikelnummer());
    student.setVorname(MUSTERMANN.getVorname());
    student.setName(MUSTERMANN.getName());
    student.setStudiengang(MUSTERMANN.getStudiengang());
    student.setSemester(MUSTERMANN.getSemester());
    student.setImmatrikuliertSeit(MUSTERMANN.getImmatrikuliertSeit());

    // execute
    sut.removeStudent(student);

    // verify
    dataSet.studentTable.deleteRow(MUSTERMANN);
    dataSet.besuchtTable.deleteAllAssociations(MUSTERMANN);

    dbTester.assertDataBase(dataSet);
  }
  
  ...

}  
  \end{lstlisting}
  
  In den Zeilen 41 und 42 werden die erwarteten Änderungen im DataSet ebenfalls durchgeführt, um in Zeile 44 die
  Datenbank gegen das DataSet zu vergleichen.
  
  Die neue DSL kann in Groovy-basierten Tests verwendet werden. Listing \ref{listing:junittest:groovy} zeigt
  beispielhaft eine entsprechende Test-Methode. In diesem Test wird eine neue Lehrveranstaltung erstellt und
  einem Professor zugeordnet. Die Änderungen am DataSet lassen sich innerhalb der Testmethode mit derselben
	Syntax modellieren.
  
  \begin{lstlisting}[caption=Test-Methode in Groovy, label=listing:junittest:groovy]
  @Test
  @DatabaseSetup(prepare = HochschuleDataSet)
  def addLehrveranstaltung() {
    // prepare
    Lehrveranstaltung lv = new Lehrveranstaltung()
    lv.setName("Programmieren")
    lv.setProfessor(HAASE.id)
    lv.setSws(4)
    lv.setEcts(6.0)

    // execute
    def addedLv = sut.addLehrveranstaltung(lv)

    // verify
    dataSet.lehrveranstaltungTable.rows {
      id         | professor | name            | sws | ects
      addedLv.id | HAASE     | "Programmieren" | 4   | 6.0
    }

    dbTester.assertDataBase(dataSet)
  }
  \end{lstlisting}
  
  Sicherheitshalber wird die vom Service erzeugte ID verwendet, um die Änderungen am Test-DataSet
  durchzuführen. Auf diese Weise bleibt der Test stabil, auch wenn sich das Verhalten des Services
  bzw. der Datenbank bei der Vergabe von IDs ändern sollte.
    
  \section{Komposition von DataSets}
  \label{sec:ralisierungdsl:kompositiondatasets}
  
  DataSets lassen sich aus anderen zusammensetzen. Dieses Feature setzt nicht auf Konzepte
  der Objektorientierung wie Vererbung. Einerseits erlaubt Java keine Mehrfach-Vererbung, andererseits
	müssten die in der abgeleiteten Klasse überschriebenen Methoden 
  \texttt{tables} und \texttt{relations} explizit die Methoden aus der Super-Klasse aufrufen. 
  
  Der realisierte Mechanismus sieht vor, dass DataSets andere DataSet-Klassen als Basis verwenden können.
  Wenn ein DataSet genau ein anderes DataSet als Basis verwendet, kann die Methode \texttt{extendsDataSet}
	überschrieben werden, so dass sie die Klasse des Basis-DataSets zurückliefert. Analog dazu kann 
	für Mehrfach-Vererbung die Methode \texttt{extendsDataSets} überschrieben werden. Diese muss eine Liste von
	DataSet-Klassen zurückliefern. 
	
	Listing
  \ref{listing:extendeddataset} zeigt, wie ein DataSet ein anderes als Basis verwendet. 
  
  \begin{lstlisting}[caption=Erweitertes DataSet, label=listing:extendeddataset]
class ExtendedHochschuleDataSet extends HochschuleBuilder {

  def extendsDataSet() { HochschuleDataSet }

  def tables() {
	
   lehrveranstaltungTable.rows {
      REF       | id  | name                | sws | ects
      PROGR     | 3   | "Programmieren"     | 4   | 6.0
    }
  
	}

  def relations() {
    HAASE.leitet(PROGR)
  }

}  
  \end{lstlisting}
  
  Die Syntax für die Komposition aus den drei DataSet-Klassen \texttt{DataSet1}, \texttt{DataSet2} und
  \texttt{DataSet3} ist in Listing \ref{listing:multiextendeddataset} dargestellt:
  \begin{lstlisting}[caption=Erweitertes DataSet, label=listing:multiextendeddataset]
  def extendsDataSets() { [ DataSet1, DataSet2, DataSet3 ] }
  \end{lstlisting}
  
  Das erweiterte DataSet kann in denselben Unit-Tests verwendet werden. Dabei reicht es aus,
  die Annotation \texttt{DatabaseSetup} entsprechend anzupassen (siehe Listing 
  \ref{listing:junittest:extendeddataset}).
  
  \begin{lstlisting}[caption=Test auf erweitertem DataSet, label=listing:junittest:extendeddataset]
  @Test
  @DatabaseSetup(prepare = ExtendedHochschuleDataSet)
  public void assignedLehrveranstaltungen() throws Exception {
    // prepare
    Professor haase = new Professor();
    haase.setId(HAASE.id);

    // execute
    List<Lehrveranstaltung> items = sut.findLehrveranstaltungen(haase);

    // verify
    def findWhere = dataSet.lehrveranstaltungTable.findWhere
    int count = findWhere.professorId(HAASE).rowCount
    assertThat(items).hasSize(count);
  }
  \end{lstlisting}

  \section{Erweiterungen in generierter API}
  \label{sec:ralisierungdsl:apierweiterungen}
  
  Die meisten Erweiterungen an der Fluent-Builder-API-Schicht betreffen die Möglichkeit, Referenzen statt konkreter Werte
  zu verwenden. Dazu gehören unter anderem:
  
  \begin{itemize}
    \item \textbf{RowBuilder}: Die Erweiterungen der RowBuilder betreffen vor allem die verbesserten Möglichkeiten
      Relationen auszudrücken. So gibt es für Spalten, die eine Relation zu einer anderen Spalte enthalten, nun neben
      einem Setter für den konkreten Wert (z.B. des Fremdschlüssels) einen Setter zum Setzen des entsprechenden
      Referenz. 
      
      Anstelle des von der Ref repräsentierten Wertes wird die Ref selbst im RowBuilder abgespeichert. Das hat zwei
      Vorteile:
       \begin{enumerate}
        \item \textbf{Reihenfolge}: Die Modellierung der Daten ist in diesem Fall keiner strengen Reihenfolge unterworfen.
          Es ist egal, ob die Zeile, auf die Bezug genommen wird, überhaupt schon initialisiert wurde.

        \item \textbf{Konsistenz}: Die Werte werden nicht redundant gespeichert. Wird der Wert an einer Stelle geändert,
          ist dieser Wert unmittelbar im gesamten DataSet so sichtbar.
      \end{enumerate}
      
    \item \textbf{Future Values}: Eine der wenigen Erweiterungen, die nicht auf die Einführung der Referenzen zurückzuführen
      sind, sind Future Values. Dabei handelt es sich um Werte, die erst beim Abfragen ausgewertet werden. Dies kann nützlich
      sein, wenn sich Werte abhängig von anderen Daten ändern. Listing \ref{listing:futurevalues} zeigt ein Beispiel, in der
      die Lehrveranstaltungstabelle um eine Spalte erweitert wurde. Diese Spalte soll die Anzahl der Tutoren aufnehmen, die
      die Lehrveranstaltung betreuen.
    
      \begin{lstlisting}[caption=Beispiel für Future Values, label=listing:futurevalues]
class HochschuleDataSet extends HochschuleBuilder
{

  def tables() {
        
    lehrveranstaltungTable.rows {
      REF       | name                | sws | ects | tutoren
      VSYS      | "Verteilte Systeme" | 4   | 5    | tutors(VSYS)
      DPATTERNS | "Design Patterns"   | 4   | 3    | tutors(DPATTERNS)
    }
    
    ...
  }
    
  ...

  // returns a Closure which is treated as future value
  def tutors(LehrveranstaltungRef ref) {
    return {
      def rows = isttutorTable.quietFindWhere.lehrveranstaltungId(ref)
      return rows.rowCount
    }
  }
}
      \end{lstlisting}
      
      Durch die Nutzung von Future Values enthält die Tabelle immer die korrekte Anzahl, ohne dass beim Modellieren
      der Tutoren-Beziehungen Anpassungen notwendig sind. Um die Syntax übersichtlich zu halten,
			werden Closures automatisch als Future Values interpretiert. Die Methode \texttt{tutors()}
      liefert ein solches Closure zurück.


    \item \textbf{findWhere}: Das bisherige API ermöglichte das Suchen von Zeilen in einer Tabelle ausschließlich über konkrete Werte.
		  Die Erweiterung erlaubt es, dass Referenzen statt konkreter Werte verwendet werden können. Werden beispielsweise 
      in der Professor-Tabelle alle Professoren mit einem bestimmten Vornamen gesucht und als Such-Wert eine 
      Professor-Referenz übergeben, werden alle Professoren mit diesem Vornamen gesucht. Listing
      \ref{listing:apierweiterung:findexample} zeigt zwei Such-Anfragen, die in den Beispieldaten dasselbe Ergebnis
      liefern.
  
      \begin{lstlisting}[caption=Such-Beispiele, label=listing:apierweiterung:findexample]
dataSet.table_Professor.findWhere.vorname("Oliver");
dataSet.table_Professor.findWhere.vorname(HAASE);
      \end{lstlisting}

    \item \textbf{quietFindWhere}: In manchen Fällen kann es sinnvoll sein, bei einer Suche ohne Treffer keine Ausnahme
      auszulösen. Ein Beispiel dafür ist das Closure in Listing \ref{listing:futurevalues}. Eine Lehrveranstaltung ohne
      Tutoren kann in diesem Beispiel normal sein.
      
    \item \textbf{getWhere}: Wenn davon auszugehen ist, dass eine Such-Anfrage genau eine Zeile als Ergebnis liefert,
      kann \texttt{getWhere} verwendet werden. Im Gegensatz zu \texttt{findWhere} liefert es das Ergebnis nicht in Form
      einer Liste, sondern als \texttt{Optional}-Wert zurück \cite{GUAVA_OPTIONAL}. Gibt es auf eine Suchanfrage mehr
      als einen Treffer, wird eine Exception ausgelöst.
  
    \item \textbf{find}: Sind die einfachen Such-Anfragen über \texttt{findWhere} bzw. \texttt{getWhere} nicht mächtig genug,
      können mit Hilfe von \texttt{find} Filter-basierte Suchen durchgeführt werden. In Listing \ref{listing:find} wird
      ein Filter gezeigt, der alle Professoren findet, deren Vorname die Länge sechs hat.
      
      \begin{lstlisting}[caption=Beispiel für find, label=listing:find]
Filter<RowBuilder_Professor> FILTER = 
  new Filter<RowBuilder_Professor>() 
    {
      @Override
      public boolean accept(RowBuilder_Professor value)
      {
        return value.getVorname().length() == 6;
      }
    };
    
RowCollection_Professor profs = dataSet.professorTable.find(FILTER);
      \end{lstlisting}
      
      In Groovy können auch direkt Closures übergeben werden, die als Argument einen entsprechenden RowBuilder übergeben
      bekommen.
    
    \item \textbf{foreach}:
		  Ein Zugriff auf die einzelnen Zeilen in einer Tabelle kann innerhalb eines Tests sinnvoll bzw. notwendig sein.
			Neben dem Zugriff auf eine Liste von RowBuildern ist es auch möglich, mit Hilfe der Methode \texttt{foreach} 
			über die Zeilen zu iterieren. Listing \ref{listing:foreach} zeigt ein kurzes Java-Beispiel. In Groovy kann
			der Methode auch ein Closure übergeben werden, das den entsprechenden RowBuilder als Parameter übergeben bekommt.
			
      \begin{lstlisting}[caption=Beispiel für foreach, label=listing:foreach]
Action<RowBuilder_Professor> ACTION = 
  new Action<RowBuilder_Professor>() 
    {
      @Override
      public void call(RowBuilder_Professor value)
      {
        System.out.println("Professor: " + value.getName());
      }
    };
  
dataSet.professorTable.foreach(ACTION);
      \end{lstlisting}
        
  \end{itemize}
  
  \section{JavaDoc}
  \label{sec:ralisierungdsl:javadoc}
  
  Ein wichtiges Merkmal des IDE-Supports ist, dass der Tester beim Erstellen der Tests durch aussagekräftige
  JavaDoc unterstützt wird. Der Generator erzeugt eine JavaDoc für das DataSet, für die Tabellen und für die
	Referenz-Typen. Die JavaDoc beinhaltet neben der Beschreibung der Schnittstellen auch zum Datenbank-Schema
	passende Beispiel-Quellcodes, die als Vorlage dienen können.
  
  Die in der JavaDoc enthaltenen Beispiel-Daten werden auf sehr einfache Art generiert, für jeden Java-Datentyp
  gibt es einen Beispielwert. Sie sollen mit Hilfe der Erkenntnisse bezüglich der Generierung von Testdaten 
  verbessert werden.
  
	Einige der Beispiel-Quellcodes werden über Unit-Tests überprüft. Dazu gehören die Builder-Klassen zur
	Beschreibung des Datenbank-Modells. Auf diese Weise soll sichergestellt werden, dass Änderungen am API
	auch auf die JavaDoc übertragen werden.

\begin{figure}[H]
  \centering
   \includegraphics[width=0.9\textwidth]{images/realisierung/javadoc_tooltip.png}
  \caption{Beispiel JavaDoc-Tooltip}\label{img:javadoc_tooltip}
\end{figure}

  \section{Verhalten bei Fehlern in den Tabellendefinitionen}
  \label{sec:ralisierungdsl:verhaltenfehler}
  
  Selbst eine übersichtliche Darstellung von Tabellendaten schützt nicht vor Fehleingaben. Viele Fehler lassen sich mit
  Hilfe statischer Analysen erkennen. So werden ungültige Tabellen- und Spaltennamen vom Compiler entdeckt.

  Fehler in der eigentlichen Tabellenstruktur, z.B. eine abweichende Anzahl von Spalten, kann der Standard-Compiler
  nicht erkennen, genauso wie ungültige Werte bzw. ungültige Typen. Solche Fehler werden in der gegenwärtigen
  Implementierung erst zur Laufzeit erkannt und führen zum Scheitern der Tests. Dazu wirft der Tabellen-Parser eine
  Exception der Klasse \texttt{TableParserException}. Wenn ein falscher Typ verwendet wird, könnte die Meldung
  der Exception so aussehen: \textit{Cannot set value <5> of type java.lang.Integer, expected class java.lang.String
  in [TableRowModel: <JobsRef> | 5 | "Creating software"]}
  
  Um die Lokalisation der fehlerhaften Stelle zu erleichtern, wird der Stack-Trace der geworfenen Exception angepasst.
  Die Arbeitsweise Tabellen-Parsers macht dies notwendig: Der Parser arbeitet zeilenweise,
  d.h. er liest immer eine Zeile vollständig ein und interpretiert die Daten erst im Anschluss - wenn die
  Ausführung der Zeile abgeschlossen ist. Kommt es zu einem Fehler, befindet sich das Programm aber nicht mehr
  in der Zeile, die für den Fehler verantwortlich ist. Deshalb wird beim Parsen bei jedem Tabellen-Element der Stack-Trace
  analysiert und das Stack-Trace-Element bestimmt, das zu der Tabellenzeile gehört. Sollte es beim Setzen
  der Werte einen Fehler geben, wird dieses Element als erstes Element des Stack-Traces hinzugefügt.
	Der Vorteil der Stack-Trace-Manipulation ist, dass im Falle eines Fehlers der Tester schnell über den Stack-Trace
	die richtige Stelle im Code finden kann.
	

  \section{Nicht umgesetzt}
  \label{sec:ralisierungdsl:nichtumgesetzt}
  
  Der folgende Abschnitt soll einen kurzen Überblick über nicht umgesetzte Funktionen geben. Außerdem wird begründet,
  warum diese Funktionen nicht in \textit{STU} implementiert ist.

    \subsection{Zusammengesetzte Schlüssel}
    Zusammengesetzte Schlüssel werden in \textit{STU} nicht direkt unterstützt und müssen nach wie vor komplett
		manuell realisiert werden. Dazu muss für jeden Teilschlüssel eine
    Spalte im Datenbank-Modell angelegt werden. Sofern zum Zugriff auf Tabellenzeilen die Referenz-Typen
    verwendet werden, stellt das kein großes Problem dar. Sollte die Zeile in Abhängigkeit ihres
    Schlüssels dynamisch gesucht werden, kann auf die neue \texttt{find}-Methode zurückgegriffen werden.

    \subsection{Unterstützung für weitere Beziehungstypen}
    Folgende Beziehungstypen müssen manuell umgesetzt werden.
    
    \begin{itemize}
      \item \textbf{Reflexive Beziehungen}
        Eine reflexive Beziehung kann in \textit{STU} nur manuell ausgedrückt werden. Die Definition einer
        einfachen Tabelle für einen Baum, der aus einzelnen Knoten besteht, könnte wie folgt aussehen
        (siehe Listing \ref{listing:reflexiv:manuell}). Ein Knoten-Element kennt den zugehörigen Eltern-Knoten
        (Zeile 5). Eine Referenz auf die Tabelle ist an dieser Stelle nicht möglich, die Relation muss
        manuell ohne besondere Tool-Unterstützung durch \textit{STU} realisiert werden.
      
        \begin{lstlisting}[caption=Reflexive Beziehungen manuell, label=listing:reflexiv:manuell]
Table knoten = table("knoten")
    .column("id", DataType.BIGINT)
      .defaultIdentifier()
    .column("name", DataType.VARCHAR)
    .column("parent", DataType.BIGINT)
  .build();
        \end{lstlisting} 
        
        Die Konsequenz ist, dass die Beziehungen nicht typsicher über die Referenz-Klasse modelliert werden
        können, sondern die Primär- und Fremdschlüssel manuell im DataSet gepflegt werden müssen.
        
        Ein anderer Ansatz stellt das Refaktorisieren der Datenbank und der beteiligten Systeme dar. Dies ist
        leider nicht immer möglich. Die Refaktorisierung sieht eine assoziative Tabelle für die Modellierung
        der Beziehung vor (siehe Listing \ref{listing:reflexiv:assoc}).
        
        \begin{lstlisting}[caption=Reflexive Beziehungen mit Hilfe assoziativer Tabelle, label=listing:reflexiv:assoc]
Table knoten = table("knoten")
    .column("id", DataType.BIGINT)
      .defaultIdentifier()
    .column("name", DataType.VARCHAR)
  .build();

associativeTable("parents")
    .column("parent", DataType.BIGINT)
      .reference
        .foreign(knoten)
    .column("child", DataType.BIGINT)
      .reference
        .foreign(knoten)
  .build();
        \end{lstlisting} 

      \item \textbf{Zirkuläre Beziehungen}
				Reflexive Beziehungen stellen eine besondere Form von zirkulären Beziehungen dar. Die Probleme sind
				relativ ähnlich. Als kleines Modell dient eine Veranstaltungsplanung, bei der es Organisatoren
				und Teilnehmer geben kann. Eine Veranstaltung wird von einer Person organisiert, eine Person
				kann an einer Veranstaltung teilnehmen. Listing \ref{listing:zirkulaer:manuell} zeigt eine
				Realisierung dieses Modells.

        \begin{lstlisting}[caption=Zirkuläre Beziehungen manuell, label=listing:zirkulaer:manuell]
Table event = table("event")
    .column("id", DataType.BIGINT)
      .defaultIdentifier()
    .column("name", DataType.VARCHAR)
    .column("organizer", DataType.BIGINT)  // a person
  .build();

Table person = table("person")
    .column("id", DataType.BIGINT)
      .defaultIdentifier()
    .column("name", DataType.VARCHAR)
    .column("participates", DataType.BIGINT)
      .reference
        .foreign(event)
  .build();
        \end{lstlisting} 
      
			  Dasselbe Modell lässt sich -- aus Sicht von \textit{STU} -- etwas typsicherer umsetzen.
				Für die Teilnahme wird eine assoziative Tabelle verwendet. Darüber hinaus kann hier auch
				eine Person an mehreren Veranstaltungen teilnehmen. Listing \ref{listing:zirkulaer:assoc}
				zeigt die Realisierung einer zirkulären Beziehung mit Hilfe einer assoziativen Tabelle.
      
        \begin{lstlisting}[caption=Zirkuläre Beziehungen mit assoziativer Tabelle, label=listing:zirkulaer:assoc]
Table person = table("person")
    .column("id", DataType.BIGINT)
      .defaultIdentifier()
    .column("name", DataType.VARCHAR)
  .build();

Table event = table("event")
    .column("id", DataType.BIGINT)
      .defaultIdentifier()
    .column("name", DataType.VARCHAR)
    .column("organizer", DataType.BIGINT)
  .build();

associativeTable("parcipations")
    .column("event", DataType.BIGINT)
      .reference
        .foreign(event)
    .column("participant", DataType.BIGINT)
      .reference
        .foreign(person)
  .build();
        \end{lstlisting} 
      
      \item \textbf{Ternäre und andere höhergradige Beziehungen}
			  \textit{STU} sieht keine spezielle Unterstützung für ternäre oder andere höhergradige Beziehungen vor.
				Es bietet sich an, solche Beziehungen über eine zusätzliche Tabelle zu realisieren (siehe Listing
				\ref{listing:hoehergradig}, vergleichbar mit assoziativen Beziehungen für die Modellierung von
				n:m-Beziehungen.

        \begin{lstlisting}[caption=Höhergradige Beziehungen mit zusätzlicher Tabelle, label=listing:hoehergradig]
Table student = table("student")
    .column("id", DataType.BIGINT)
      .defaultIdentifier()
    .column("name", DataType.VARCHAR)
  .build();

Table professor = table("professor")
    .column("id", DataType.BIGINT)
      .defaultIdentifier()
    .column("name", DataType.VARCHAR)
  .build();

Table pruefung = table("pruefung")
    .column("id", DataType.BIGINT)
      .defaultIdentifier()
    .column("name", DataType.VARCHAR)
  .build();

table("relation")
    .column("student_id", DataType.BIGINT)
      .reference
        .foreign(student)
    .column("professor_id", DataType.BIGINT)
      .reference
        .foreign(professor)
    .column("pruefung_id", DataType.BIGINT)
      .reference
        .foreign(pruefung)
  .build();
        \end{lstlisting} 
			
    \end{itemize}
  
    \subsection{Komfortfunktionen}
    
    Die Realisierung könnte an manchen Stellen dem Test-Ingenieur mehr manuelle Arbeit abnehmen. So wird darauf verzichtet,
    beim Löschen einer Zeile aus einer Tabelle auch alle beteiligten Beziehungen zu entfernen. Listing \ref{listing:deleteexample}
    zeigt, wie ein Professor aus der Professoren-Tabelle entfernt wird. Die erste Zeile entfernt keine Einträge in 
    anderen Tabellen wie z.B. der Beaufsichtigt-Tabelle. Folglich müssen die Relationen (mehr oder weniger) manuell
    aus anderen Tabellen entfernt werden.

    \begin{lstlisting}[caption=Löschen von Zeilen, label=listing:deleteexample]
dataSet.professorTable.deleteRow(HAASE);
dataSet.beaufsichtigtTable.deleteAllAssociations(HAASE);
    \end{lstlisting} 
  
    Diese Entscheidung hat unterschiedliche Gründe:
    \begin{itemize}
      \item \textbf{Einsatzgebiet}: Die Bibliothek soll Unit-Tests in Verbindung mit Datenbanken vereinfachen. Es handelt sich
        hier nicht um ein API, das in einer Anwendung ausgeliefert wird. Während es in einem API für produktive Anwendungen
        durchaus sinnvoll sein kann, dass das System beim Löschen von Entitäten gewisse Aufgaben automatisch erledigt,
        ist so ein Verhalten innerhalb einer Test-Bibliothek zweifelhaft. Explizites Löschen von Zeilen auf allen beteiligten
        Tabellen verbessert die Ausdrucksstärke des Tests.
        
      \item \textbf{Code-Qualität}: Eine Funktion (bzw. Methode) sollte genau eine Aufgabe erledigen. Wenn
        \texttt{deleteRow} zusätzlich beteiligte Relationen auflöst, erledigt diese Funktion mehr als nur eine Aufgabe 
        \cite[65f]{CLEAN_CODE}. Außerdem würde es sich um einen unerwarteten Nebeneffekt handeln \cite[75f]{CLEAN_CODE}.
      
      \item \textbf{Klarheit}: Es ist nicht eindeutig, wie beim Entfernen von Zeilen vorgegangen werden soll, wenn sie
        Teil einer Relation sind. Bei einer n:m-Relation könnte sich die Regel ableiten lassen, dass beim Löschen einer
        Zeile auch alle assoziierten n:m-Relationen entfernt werden können. Aber was ist bei einer 1:n-Relation? Wenn
        ein Professor entfernt wird, was soll mit Lehrveranstaltungen passieren, die ihm zugeordnet sind?
    \end{itemize}
