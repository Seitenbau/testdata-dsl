\chapter{Generieren von Testdaten}
\label{chap:generieren}

Es gibt verschiedene Ansätze zur Generierung von Testdaten für Datenbank-basierte Anwendungen:
\begin{enumerate}
  \item \textbf{Modell-basierte Generierung}:
  	Anhand eines Datenbank-Modells werden Entitäten mit Zufallswerten für die Attribute (Spalten) erzeugt. Es gibt
  	einige kommerzielle Werkzeuge aber auch frei nutzbare Internet-Seiten für die Generierung. 
  
  \item \textbf{Abfrage-basierte Generierung}:
  	Ausgehend von konkreten Abfragen (z.B. in SQL) werden für die Abfrage passende Daten erzeugt. 
  	RQL Quelle
  
  \item \textbf{Anonymisierung realer Daten}:
  	Bei diesem Ansatz findet keine echte Generierung statt. Stattdessen werden Daten einer realen Anwendung 
  	anonymisiert und für Tests verwendet.
  
\end{enumerate}

Für diese Arbeit scheint nur die erste Variante sinnvoll zu sein: Für die Generierung der DSL liegt bereits
ein Datenbank-Modell vor. Konkrete Anfragen als Grundlage für die Generierung sind nicht sinnvoll, da sie
vom SUT verborgen werden können. Die Anonymisierung realer Daten stellt keine Daten-Generierung
im eigentliche Sinn dar und setzt bestehende Daten voraus.

Eine Auswahl existierender Modell-basierter Datengeneratoren wird im folgenden Abschnitt analysiert.


\section{Analyse existierender Werkzeuge}
\label{chap:generieren:analyse}

Die Analyse der Werkzeuge beschränkt sich auf folgende kommerzielle Anwendungen:
\begin{itemize}
  \item Datanamic Data Generator MultiDB
  \item DTM Data Generator
  \item forSQL Data Generator
  \item Red Gate SQL Data Generator
\end{itemize}

Insgesamt sind die Möglichkeiten der Anwendungen relativ ähnlich. Die größten Unterschiede aus Nutzer-Sicht liegen in der
Bedienung. Die Werkzeuge arbeiten zufallsbasiert aber deterministisch, d.h. sie erzeugen bei gleichem Modell die gleichen
Daten. Das sogenannte \textit{Seed}, mit dem der Zufallszahlengenerator für eine einzelne Spalte initialisiert wird, lässt
sich z.B. beim Red Gate SQL Data Generator komfortabel festlegen.

Die Werkzeuge sind vor allem für die Generierung von Massen-Daten vorgesehen. Dies zeigt sich auch darin, dass 
sie Beziehungen auch nur zufällig modellieren. Über eine entsprechend große Menge an Testdaten sollte dann auch jeder
notwendige Fall abgedeckt sein. Die Menge der zu erzeugenden Testdaten lässt sich für jede einzeln Tabelle konfigurieren.

Die von dem zu entwickelnden Generator erzeugten Testdaten sollen allerdings überschaubar und wartbar sein. Dies steht
in Widerspruch mit einer Massendatengenerierung. Aus diesem Grund soll ein Algorithmus entwickelt werden, der
Beziehungen nicht nur zufällig modelliert, sondern möglichst alle Grenzfälle erzeugt. Äquivalenzklassenbildung und
Grenzwertanalyse sind ein bewährtes Vorgehen, um die Menge von Test-Daten zu reduzieren. 


\section{Generierung von Beziehungen}

Der zu entwickelnde Algorithmus übernimmt das Konzept der Äquivalenzklassenbildung und Grenzwertanalyse, um möglichst
alle notwendigen Beziehungskombinationen zwischen zwei Entitätstypen zu modellieren. Die Menge der zu generierenden
Entitäten soll dabei möglichst gering gehalten werden.

Unterschiedliche Beziehungstypen stellen unterschiedliche Anforderungen an den Daten-Generator. Binäre Beziehungen
lassen sich in die drei Hauptkategorien 1:1, 1:n und n:m einordnen. Die folgenden Abbildungen die zu generierenden
Entitäten der beiden Entitätstypen A und B dar. Eine Entität wird von einem kleinen Kreis repräsentiert, ihr 
Entitätstyp über die Spalte festgelegt. Eine Beziehung zwischen zwei Entitäten wird über eine Verbindungsgerade
beschrieben. Grundsätzlich können die beiden Typen A und B auch den selben Typen darstellen.

Ganz allgemein lassen sich alle binären Beziehungen als n..N:m..M-Beziehung ansehen. n und m stellen jeweils
untere Grenzen darf, N und M die oberen. Die grundlegende Generierungsstrategie sieht die Generierung der folgenden
vier Kombinationen vor:
\begin{itemize}
  \item n:m
  \item n:M
  \item N:m
  \item N:M
\end{itemize}
Verschiedene Fälle können redundant sein, falls untere und obere Grenze identisch sind. Auf die Generierung dieser
redundanten Beziehungen kann verzichtet werden.

Die Abbildungen stellen dar, welche Entitäten \textit{mindestens} generiert werden sollten.

  \subsection{Kategorie der 1:1-Beziehungen}
  
  Unter die Kategorie 1:1-Beziehung fallen alle Beziehungen, bei denen eine oder keine Entität mit genau einer oder
  keiner Entität in Beziehung stehen kann.
  
  	\subsubsection{1..1:1..1}
  	
  	Eine Entität des Typs A steht mit genau einer Entität des Typs B in Beziehung. Die Anzahl der generierten Entitäten
  	muss übereinstimmen, es muss mindestens eine Entität pro Typ erzeugt werden (siehe Abbildung \ref{img:generierung:11to11}).
  	
  	\begin{figure}[htbp]
  	  \centering
  	   \includegraphics[width=0.55\textwidth]{images/generierung/1-1-to-1-1.png}
  	  \caption{Beziehungen nach dem Schema 1..1:1..1}\label{img:generierung:11to11}
  	\end{figure}

  	
  	\subsubsection{0..1:1..1}
  	
  	Im Gegensatz zu der vorherigen Beziehung muss bei dieser eine Entität nicht zwingend in Beziehung mit einer anderen stehen.
  	Abbildung \ref{img:generierung:01to11} zeigt die zu generierenden Entitäten der Typen A und B, wobei jede Entität von A
  	mit einer Entität von B in Beziehung stehen muss, eine Entität von B jedoch nicht zwingend mit einer Entität von A.
  	Daraus folgt, dass es von B mindestens eine Entität mehr geben muss als von A.

  	\begin{figure}[htbp]
  	  \centering
  	   \includegraphics[width=0.55\textwidth]{images/generierung/0-1-to-1-1.png}
  	  \caption{Beziehungen nach dem Schema 0..1:1..1}\label{img:generierung:01to11}
  	\end{figure}

  	Der Generator muss mindestens zwei Entitäten des Typs B erzeugen, und eine des Typs A, um sicherzustellen, dass alle
  	Fälle für diese Beziehung abgedeckt sind. Die Beziehung 1..1:0..1 ist symmetrisch zu dieser.
  	

  	\subsubsection{0..1:0..1}
  	
  	Wenn für beide Entitätstypen die Beziehung optional ist, muss der Generator jeweils mindestens 2 Entitäten erzeugen. Jeweils
  	eine Entität ohne Beziehung und jeweils eine Entität mit einer Beziehung (siehe Abbildung \ref{img:generierung:01to01}).

  	\begin{figure}[htbp]
  	  \centering
  	   \includegraphics[width=0.55\textwidth]{images/generierung/0-1-to-0-1.png}
  	  \caption{Beziehungen nach dem Schema 0..1:0..1}\label{img:generierung:01to01}
  	\end{figure}

  \subsection{Kategorie der 1:n-Beziehungen}
  
  Eine Entität steht in Beziehung mit keiner oder mehreren anderen Entitäten. Dabei kann die Anzahl begrenzt sein (konkreter
  Wert für n) oder unbegrenzt. Der Generator kann nur eine begrenzte Anzahl von Entitäten erzeugen, die Grenze sollte
  konfigurierbar sein.
  
  In den Abbildungen wird als Grenze n der Wert 3 verwendet.

  	\subsubsection{1..1:1..n}
  	
  	Die einfachste Form der 1:n-Beziehungen. Eine Entität des Typs A ist in einer Beziehung mit einer oder mehreren Entitäten
  	des Typs B. Eine Entität des Typs B ist mit genau einer Entität des Typs A in Beziehung.

  	\begin{figure}[htbp]
  	  \centering
  	   \includegraphics[width=0.55\textwidth]{images/generierung/1-1-to-1-n.png}
  	  \caption{Beziehungen nach dem Schema 1..1:1..n}\label{img:generierung:11to1n}
  	\end{figure}

  	\subsubsection{0..1:1..n}
  	
  	Eine Entität des Typs A steht in Beziehung mit einer oder mehreren Entitäten des Typs B. Eine Entität des Typs B steht
  	entweder mit genau einer oder mit keiner Entität des Typs A in Beziehung. 

  	\begin{figure}[htbp]
  	  \centering
  	   \includegraphics[width=0.55\textwidth]{images/generierung/0-1-to-1-n.png}
  	  \caption{Beziehungen nach dem Schema 0..1:1..n}\label{img:generierung:01to1n}
  	\end{figure}
  	
  	\subsubsection{1..1:0..n}
  	
  	Eine Entität des Typs A steht in Beziehung mit keiner, einer oder mehreren Entitäten des Typs B. Eine Entität des Typs B
  	muss mit genau einer Entität des Typs A in Beziehung stehen.

  	\begin{figure}[htbp]
  	  \centering
  	   \includegraphics[width=0.55\textwidth]{images/generierung/1-1-to-0-n.png}
  	  \caption{Beziehungen nach dem Schema 1..1:0..n}\label{img:generierung:11to0n}
  	\end{figure}



  	\subsubsection{0..1:0..n}
		
		Eine Entität des Typs A steht mit keiner, einer oder mehreren Entitäten des Typs B in Beziehung. Eine Entität des Typs B
		kann mit keiner oder genau einer Entität des Typs A in Beziehung stehen.

  	\begin{figure}[htbp]
  	  \centering
  	   \includegraphics[width=0.55\textwidth]{images/generierung/0-1-to-0-n.png}
  	  \caption{Beziehungen nach dem Schema 0..1:0..n}\label{img:generierung:01to0n}
  	\end{figure}

  \subsection{Kategorie der n:m-Beziehungen}
	\label{sec:generieren:beziehungen:nm}
		
	Die allgemeinste Form einer Beziehung zwischen zwei Eintitätstypen stellt eine n..N:m..M-Beziehung dar. Dabei handelt es
	sich bei n und m jeweils um untere und bei N und M jeweils um obere Schranken. Untere und obere Schranken können
	identisch sein.
	
	Sofern beide obere Grenzen größer sind als 1, wird eine solche Beziehung in einem Datenbank-Modell üblicherweise über
	assoziative Tabellen realisiert.

  üblicherweise als assoziative Tabelle realisiert

\section{Komplexität bei der Generierung von Beziehungen}
\label{sec:generieren:komplexitaet}

Im vorausgegangenen Abschnitt wurden nur Beziehungen zwischen zwei Entitätstypen betrachtet. In realen Anwendungen können
Entitätstypen mit mehr als nur einem anderen Entitätstyp in Beziehung stehen und auch mit dem selben Entitätstyp mehr als
nur ein Mal.

Bezüglich der Datengenerierung lassen sich hierbei zwei generelle Vorgehensweisen lassen sich hier unterscheiden:
\begin{itemize}
	\item \textbf{Beziehungen unabhängig betrachten}: Es wird angenommen, dass unterschiedliche Beziehungen voneinander
	  unabhängig sind. Die Frage, ob ein Professor eine Lehrveranstaltung leitet, lässt keine Rückschlüsse zu, ob und welche
		Prüfungen er beaufsichtigt.
	
	\item \textbf{Beziehungen abhängig voneinander betrachten}: In der Praxis beeinflussen sich Beziehungen. Ein Student,
	  der die Prüfung einer Lehrveranstaltung schreibt, darf wohl nicht gleichzeitig Tutor dieser Veranstaltung sein.
	
\end{itemize}

Alle Beziehungen abhängig voneinander zu betrachten kann schnell zu exponentiell zunehmenden Testdaten führen. 
Einen riesigen Bestand an Daten um für Tests unnötige Beziehungen und schließlich auch Entitäten zu verringern
scheint aufwändiger, als einen kleinen Datenbestand um fehlende Beziehungen punktuell zu erweitern. Aus diesem Grund
berücksichtigt der Algorithmus keine Beziehungen in Abhängigkeit von anderen -- mit Ausnahme von assoziativen
Beziehungen.

\section{Algorithmus zur Generierung von Beziehungen}
\label{sec:generieren:algorithmus}

	\subsection{Begriffserklärungen}
	
		\subsubsection{Kanten}
		
		- Idee, Diagramm als Graph aus Paper
	
		- repräsentiert Beziehung zwischen zwei Entitätstypen
		
		- gerichtet
		
		- hat Start und Ziel
		
		- Traversierung in beide Richtungen möglich
	
		\subsubsection{Assoziative Tabellen}
		
		- Einteilung in linke und rechte Kante
	
	

  \subsection{Pseudocode}
  \label{sec:generieren:algorithmus:pseudocode}
	
		\subsubsection{GeneriereTestDaten}
		
		Die Funktion GeneriereTestDaten ist der Einstiegspunkt für den Algorithmus zur Generierung von Test-Daten.
		Im ersten Schritt wird die Reihenfolge der Tabellen festgelegt, die als Startpunkte in Frage kommen. Die Liste
		stellt sicher, dass auch Datenbank-Modelle, die aus mehreren unabhängigen Graphen bestehen, vollständig
		generiert werden. In einem Datenbank-Modell, in dem alle Tabellen direkt oder indirekt in Beziehung stehen,
		würde die Festlegung einer Starttabelle ausreichen.
		
		Zur Sortierung der Tabellen wird die Anzahl eingehender Kanten verwendet. Dieser Ansatz stammt aus dem 
		Paper ... .
		
		Anschließend wird über diese Tabellenliste iteriert. Wurde eine Tabelle noch nicht behandelt, wird die
		entsprechende Methode zur Generierung der Daten aufgerufen. Dabei werden nicht-assoziative und
		assoziative Tabellen unterschiedlich generiert. Der Grund dafür ist, dass assoziative Tabellen ein
		Hilfskonstrukt darstellen, das selbst eine Beziehung auf ER-Ebene darstellt.
		
		Am Ende stellt der Algorithmus sicher, dass jede Entität gültig generiert wurde, also dass die Beziehungen
		die Constraints erfüllen. Gegebenenfalls werden hier Entitäten nach generiert.
  
\begin{lstlisting}[caption=GeneriereTestDaten, label=listing:GeneriereTestDaten]
GeneriereTestDaten
------------------
L := nach Anzahl eingehender Kanten aufsteigend geordnete Tabellenliste;
FOR EACH (noch nicht besuchte Tabelle T IN der geordneten Tabellenliste L)
DO
  Markiere Tabelle T als besucht;
  IF (Tabelle T ist keine assoziative Tabelle)
  THEN CALL GeneriereDatenFuerNichtassoziativeTabelle(T);
  ELSE CALL GeneriereDatenFuerAssoziativeTabelle(T);
  END IF;
END FOR;
CALL "ErweitereGenerierteDatenzuKonsistenenDaten"()
\end{lstlisting}

		\subsubsection{GeneriereDatenFuerNichtassoziativeTabelle}
		
		Der Generator betrachtet zur Generierung von Entitäten die Beziehungen der Tabellen. Deshalb erzeugt die
		Funktion zur Generierung von Daten für nicht-assoziative Tabellen selbst keine Daten. Stattdessen werden
		die (noch unbehandelten) Beziehungen/Kanten der Tabelle betrachtet. 
		
		Handelt es sich bei der an der Beziehung beteiligten Tabelle um eine assoziative Tabelle, wird mit der
		Generierung der assoziativen Beziehungen fortgesetzt. Ansonsten wird die Funktion zur Generierung der
		Daten für eine Kante aufgerufen.
		
	  Der Algorithmus bevorzugt ausgehende Kanten.

\begin{lstlisting}[caption=GeneriereDatenFuerNichtassoziativeTabelle, label=listing:GeneriereDatenFuerNichtassoziativeTabelle]
GeneriereDatenFuerNichtassoziativeTabelle(Tabelle T)
---------------------------------------------------
FOR EACH (ausgehende Kante K, die noch nicht besucht wurde)
DO
  IF (Zieltabelle Z von Kante K ist keine assoziative Tabelle)
  THEN Markiere Kante K als besucht;
       CALL GeneriereDatenFuerKante(K);
			 IF (Zieltabelle Z noch nicht besucht) 
			 THEN Markiere Tabelle Z als besucht;
            CALL GeneriereDatenFuerNichtAssoziativeTabelle(Z);
			 END IF;
  ELSE CALL generiereDatenFuerAssoziativeTabelle(Z);
  END IF;
END FOR;
FOR EACH (eingehende Kante K, die noch nicht besucht wurde)
DO
  IF (Starttabelle S von Kante K ist keine assoziative Tabelle)
  THEN Markiere Kante K als besucht;
       CALL GeneriereDatenFuerKante(K);
			 IF (Starttabelle S noch nicht besucht) 
			 THEN Markiere Tabelle S als besucht;
            CALL GeneriereDatenFuerNichtAssoziativeTabelle(S);
			 END IF;
  ELSE CALL generiereDatenFuerAssoziativeTabelle(S);
  END IF;
END FOR;
\end{lstlisting}

		\subsubsection{GeneriereDatenFuerKante}
		
		Die Funktion zum Generieren von Daten für eine Kante setzt die führt die 
		\ref{sec:generieren:beziehungen:nm} beschriebenen Schritte um. Es werden alle vier Kombinationen aus
		Minimum und Maximum behandelt. Die eigentliche Generierung findet ist in eine Hilfsfunktion ausgelagert,
		die mit allen Min-Max-Kombinationen aufgerufen wird.

\begin{lstlisting}[caption=GeneriereDatenFuerKante, label=listing:GeneriereDatenFuerKante]
GeneriereDatenFuerKante(Kante K)   
------------------------------
S := Starttabelle von Kante K;
Z := Zieltabelle von Kante K;
// Generierung der Daten entsprechend Abschnitt 6.2.3 bzw. 6.2.4
CALL GeneriereEntitätenUndBeziehungen(K, min(S), min(Z));
CALL GeneriereEntitätenUndBeziehungen(K, min(S), max(Z));
CALL GeneriereEntitätenUndBeziehungen(K, max(S), min(Z));
CALL GeneriereEntitätenUndBeziehungen(K, max(S), max(Z));
\end{lstlisting}

		\subsubsection{GeneriereEntitaetenUndBeziehungen}
		
		Es soll vermieden werden, unnötige Entitäten und Beziehungen zu generieren. Unnötig sind vor allem
		redundante Beziehungen. Deshalb wird für jede Kombination aus Kante, Anzahl der beteiligten Entitäten
		der Starttabelle und Anzahl der beteiligten Entitäten der Zieltabelle die Generierung nur ein einziges
		Mal durchgeführt. Eine solche Redundanz tritt beispielsweise ein, wenn untere und obere Grenze
		einer Multiplizität identisch sind.
		
		Der Algorithmus prüft, ob es sich um eine optionale Beziehung handelt. Eine der Grenzen s bzw. z
		ist in einem solchen Fall gleich 0. Handelt es sich um eine optionale Beziehung, wird eine entsprechende
		Entität berechnet, die in Bezug auf die Kante in keiner Beziehung ist. Anschließend wird die Funktion
		rekursiv aufgerufen, diesmal mit dem Wert 1 als Grenze anstelle der 0.
		
		Sofern s und z beide ungleich 0 sind, wird eine Entität in der Zieltabelle berechnet und s Entitäten 
		in der Starttabelle. Zwischen diesen Entitäten wird die von der Kante K repräsentierte Beziehung
		hergestellt.
		
		Der Eingangswert z kann aufgrund der Tatsache, dass es sich um eine nicht-assoziative Tabelle handelt,
		nur 0 oder 1 sein.
		
\begin{lstlisting}[caption=GeneriereEntitaetenUndBeziehungen, label=listing:GeneriereEntitaetenUndBeziehungen]
GeneriereEntitaetenUndBeziehungen(K, s, z)
-----------------------------------------
// Sicherstellen, dass nicht mehr Entitäten als notwendig erzeugt werden
IF (Für die Kombination (K, s, z) wurden bereits Entitäten erzeugt) 
THEN RETURN;
END IF
IF (Wert der Grenze s ist 0)
THEN Berechne Entität e in Zieltabelle, die in keiner Beziehung zur Starttabelle stehen darf;
     CALL GeneriereEntitaetenUndBeziehungen(k, 1, z);
ELSE IF (Wert der Grenze z ist 0)
THEN Berechne Entität e in Starttabelle, die in keiner Beziehung zur Zieltabelle stehen darf;
     CALL GeneriereEntitaetenUndBeziehungen(k, s, 1);
ELSE // z ist hier immer 1
     Berechne Entität e in Zieltabelle, die in keiner Beziehung zur Starttabelle stehen darf;
		 FOR i = 1 TO s
		 DO 
       Berechne Entität se in Starttabelle, die in keiner Beziehung zur Zieltabelle stehen darf;
		   Stelle Beziehung zwischen Entität se und Entität e her;
		 END FOR;
END IF;
\end{lstlisting}

		\subsubsection{GeneriereDatenFuerAssoziativeTabelle}
		
		Assoziative Tabellen werden typischerweise zur Modellierung von n..N:m..M-Beziehungen verwendet. Diese Beziehungen
		werden entsprechend der in Abschnitt \ref{sec:generieren:beziehungen:nm} beschriebenen Strategie generiert. D.h. es
		werden alle vier Kombinationen aus den jeweiligen Minimal- und Maximalwerten betrachtet.
		
		Nach der Erzeugung der Daten für die assoziative Tabelle versucht der Algorithmus, die Generierung bei den beiden
		assoziierten Tabellen fortzusetzen -- falls diese noch nicht behandelt wurden.

\begin{lstlisting}[caption=GeneriereDatenFuerAssoziativeTabelle, label=listing:GeneriereDatenFuerAssoziativeTabelle]
GeneriereDatenFuerAssoziativeTabelle(Tabelle T)
-----------------------------------------------
LK := linke Kante der assoziativen Tabelle T;
RK := rechte Kante der assoziativen Tabelle T;
markiere Kanten LK und RK als besucht;
LM := Multiplizität der linken Beziehung, ausgehende Seite
RM := Multiplizität der rechten Beziehung, ausgehende Seite
CALL GeneriereAssoziativeEntitaetenUndBeziehungen(T, min(LM), min(RM));
CALL GeneriereAssoziativeEntitaetenUndBeziehungen(T, min(LM), max(RM));
CALL GeneriereAssoziativeEntitaetenUndBeziehungen(T, max(LM), min(RM));
CALL GeneriereAssoziativeEntitaetenUndBeziehungen(T, max(LM), max(RM));
LT := Zieltabelle von Kante LK;
RT := Zieltabelle von Kante RK;
IF (LT wurde noch nicht besucht)
THEN Markiere Tabelle LT als besucht;
     IF (Tabelle LT ist keine assoziative Tabelle)
     THEN CALL GeneriereDatenFuerNichtassoziativeTabelle(LT);
     ELSE CALL GeneriereDatenFuerAssoziativeTabelle(LT);
     END IF;
END IF;
IF (RT wurde noch nicht besucht)
THEN Markiere Tabelle RT als besucht;
     IF (Tabelle RT ist keine assoziative Tabelle)
     THEN CALL GeneriereDatenFuerNichtassoziativeTabelle(RT);
     ELSE CALL GeneriereDatenFuerAssoziativeTabelle(RT);
     END IF;
END IF;
\end{lstlisting}

		\subsubsection{GeneriereAssoziativeEntitaetenUndBeziehungen}

\begin{lstlisting}[caption=GeneriereAssoziativeEntitaetenUndBeziehungen, label=listing:GeneriereAssoziativeEntitaetenUndBeziehungen]
GeneriereAssoziativeEntitaetenUndBeziehungen(T, l, r)
----------------------------------------------------
LK := linke Kante der assoziativen Tabelle T;
RK := rechte Kante der assoziativen Tabelle T;
// Grenzen "tauschen" und Mindestanzahl auf 1
LA := Max(r, 1);  // r als Grenze, mindestens 1
RA := Max(l, 1);  // l als Grenze, mindestens 1
IF (Für die Kombination (T, LA, RA) wurden bereits Entitäten erzeugt) 
THEN RETURN;
END IF
FOR i = 1 TO RA
DO 
  Berechne Entität le[i] in linker Tabelle die in keiner Beziehung zur assoziativen Tabelle T stehen darf;
END FOR;
FOR j = 1 TO LA
DO 
  Berechne Entität re[j] in rechter Tabelle die in keiner Beziehung zur assoziativen Tabelle T stehen darf;
END FOR;
FOR i = 1 TO RA
DO 
  FOR j = 1 TO LA
  DO 
    Berechne neue Entität e in assoziativer Tabelle;
    Stelle Beziehung zwischen Entität e und Entität le[i] her;
	  Stelle Beziehung zwischen Entität e und Entität re[j] her;
  END FOR;
END FOR;
\end{lstlisting}

		\subsubsection{}

\begin{lstlisting}[caption=ErweitereGenerierteDatenzuKonsistenenDaten, label=listing:ErweitereGenerierteDatenzuKonsistenenDaten]
"ErweitereGenerierteDatenzuKonsistenenDaten"()
-----------------------------------------------
\end{lstlisting}




  \subsection{Beispiel}
	

\section{Praktischer Einsatz / Evaluation}

  \subsection{Einfluss der Tabellenreihenfolge}
	
	- unterschiedliche Reihenfolge führt zu unterschiedlichen Ergebnissen
	
	- Gesamtzahl der generierten Entitäten sollte von Reihenfolge unabhängig sein, wird aber nicht bewiesen und ist 
	  auch nicht notwendig zu beweisen
		
  - wichtig ist, dass gültige Datasets erzeugt werden

\section{Konkrete Implementierung und Integration in Toolset}

- Seeds, Default-Seed

- minEntities

- Generatoren, Standard-Generatoren



\section{Offene Punkte}

- Abhängigkeiten von Beziehungen

- Abhängigkeiten von Spaltendaten (und Beziehungen?)

    \begin{figure}[htbp]
  	  \centering
  	   \includegraphics[width=0.55\textwidth]{images/generierung/infinite.png}
  	  \caption{Unerfüllbar}\label{img:generierung:offen:infinite}
  	\end{figure}
