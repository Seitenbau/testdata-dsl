\chapter{Generieren von Testdaten}
\label{chap:generieren}

Es gibt verschiedene Ansätze zur Generierung von Testdaten für Datenbank-basierte Anwendungen:
\begin{enumerate}
  \item \textbf{Modell-basierte Generierung}:
  	Anhand eines Datenbank-Modells werden Entitäten mit Zufallswerten für die Attribute (Spalten) erzeugt. Es gibt
  	einige kommerzielle Werkzeuge aber auch frei nutzbare Internet-Seiten für die Generierung. 
  
  \item \textbf{Abfrage-basierte Generierung}:
  	Ausgehend von konkreten Abfragen (z.B. in SQL) werden für die Abfrage passende Daten erzeugt. ...
  	\cite{DBLP:conf:icde:BinnigKL07}
  
  \item \textbf{Anonymisierung realer Daten}:
  	Bei diesem Ansatz findet keine echte Generierung statt. Stattdessen werden Daten einer realen Anwendung 
  	anonymisiert und für Tests verwendet.
  
\end{enumerate}

Für die Generierung eines Standard Fixtures scheint nur die erste Variante sinnvoll zu sein: Es liegt bereits
ein Modell vor und die generierten Daten sollen idealerweise für alle Tests verwendet werden können.
Konkrete Anfragen als Grundlage für die Generierung sind nicht sinnvoll. Einerseits können sie
vom SUT verborgen werden können, andererseits eigenen sie eher für Fixtures, die für einen einzelnen Unit-Test
geeignet sind. Die Anonymisierung realer Daten stellt keine Daten-Generierung im eigentlichen Sinn dar und
setzt bestehende Daten voraus.

Eine Auswahl existierender Modell-basierter Datengeneratoren wird im folgenden Abschnitt analysiert.


\section{Betrachtung existierender Werkzeuge}
\label{chap:generieren:analyse}

Die Analyse der Werkzeuge beschränkt sich auf folgende kommerzielle Anwendungen:
\begin{itemize}
  \item Datanamic Data Generator MultiDB
  \item DTM Data Generator
  \item forSQL Data Generator
  \item Red Gate SQL Data Generator
\end{itemize}

Insgesamt sind die Möglichkeiten der Anwendungen relativ ähnlich. Die größten Unterschiede aus Nutzer-Sicht liegen in der
Bedienung. Die Werkzeuge arbeiten zufallsbasiert aber deterministisch, d.h. sie erzeugen bei gleichem Modell die gleichen
Daten. Das sogenannte \textit{Seed}, mit dem der Zufallszahlengenerator für eine einzelne Spalte initialisiert wird, lässt
sich z.B. beim Red Gate SQL Data Generator komfortabel festlegen.

Die Werkzeuge sind vor allem für die Generierung von Massen-Daten vorgesehen. Dies zeigt sich auch darin, dass 
sie Beziehungen auch nur zufällig modellieren. Über eine entsprechend große Menge an Testdaten sollte dann auch jeder
notwendige Fall abgedeckt sein. Die Menge der zu erzeugenden Testdaten lässt sich für jede einzeln Tabelle konfigurieren.
Eigene Vorschläge, wie viele Daten generiert werden sollten, machen die Werkzeuge nicht.

	\subsection{Fazit}
	Die von dem zu entwickelnden Generator erzeugten Testdaten sollen allerdings überschaubar und wartbar sein. Dies steht
	in Widerspruch mit einer Massendatengenerierung. Aus diesem Grund soll ein Algorithmus entwickelt werden, der
	Beziehungen nicht nur zufällig generiert, sondern möglichst alle Grenzfälle erzeugt. Äquivalenzklassenbildung und
	Grenzwertanalyse sind ein bewährtes Vorgehen, um die Menge von Test-Daten zu reduzieren. 
	
	
	


\section{Generierung von Beziehungen}

Der zu entwickelnde Algorithmus übernimmt das Konzept der Äquivalenzklassenbildung und Grenzwertanalyse, um möglichst
alle notwendigen Beziehungskombinationen zwischen zwei Entitätstypen zu modellieren. Die Menge der zu generierenden
Entitäten soll dabei möglichst gering gehalten werden.

Unterschiedliche Beziehungstypen stellen unterschiedliche Anforderungen an den Daten-Generator. Binäre Beziehungen
lassen sich in die drei Hauptkategorien 1:1, 1:n und n:m einordnen. Die folgenden Abbildungen die zu generierenden
Entitäten der beiden Entitätstypen A und B dar. Eine Entität wird von einem kleinen Kreis repräsentiert, ihr 
Entitätstyp über die Spalte festgelegt. Eine Beziehung zwischen zwei Entitäten wird über eine Verbindungsgerade
beschrieben. Grundsätzlich können die beiden Typen A und B auch den selben Typen darstellen.

Ganz allgemein lassen sich alle binären Beziehungen als n..N:m..M-Beziehung ansehen. n und m stellen jeweils
untere Grenzen darf, N und M die oberen. Die grundlegende Generierungsstrategie sieht die Generierung der folgenden
vier Kombinationen vor:
\begin{itemize}
  \item n:m
  \item n:M
  \item N:m
  \item N:M
\end{itemize}
Verschiedene Fälle können redundant sein, falls untere und obere Grenze identisch sind. Auf die Generierung dieser
redundanten Beziehungen kann verzichtet werden.

Die Abbildungen stellen dar, welche Entitäten \textit{mindestens} generiert werden sollten.

  \subsection{Kategorie der 1:1-Beziehungen}
  
  Unter die Kategorie 1:1-Beziehung fallen alle Beziehungen, bei denen eine oder keine Entität mit genau einer oder
  keiner Entität in Beziehung stehen kann.
  
  	\subsubsection{1..1:1..1}
  	
  	Eine Entität des Typs A steht mit genau einer Entität des Typs B in Beziehung. Die Anzahl der generierten Entitäten
  	muss übereinstimmen, es muss mindestens eine Entität pro Typ erzeugt werden (siehe Abbildung \ref{img:generierung:11to11}).
  	
  	\begin{figure}[htbp]
  	  \centering
  	   \includegraphics[width=0.55\textwidth]{images/generierung/1-1-to-1-1.png}
  	  \caption{Beziehungen nach dem Schema 1..1:1..1}\label{img:generierung:11to11}
  	\end{figure}

  	
  	\subsubsection{0..1:1..1}
  	
  	Im Gegensatz zu der vorherigen Beziehung muss bei dieser eine Entität nicht zwingend in Beziehung mit einer anderen stehen.
  	Abbildung \ref{img:generierung:01to11} zeigt die zu generierenden Entitäten der Typen A und B, wobei jede Entität von A
  	mit einer Entität von B in Beziehung stehen muss, eine Entität von B jedoch nicht zwingend mit einer Entität von A.
  	Daraus folgt, dass es von B mindestens eine Entität mehr geben muss als von A.

  	\begin{figure}[htbp]
  	  \centering
  	   \includegraphics[width=0.55\textwidth]{images/generierung/0-1-to-1-1.png}
  	  \caption{Beziehungen nach dem Schema 0..1:1..1}\label{img:generierung:01to11}
  	\end{figure}

  	Der Generator muss mindestens zwei Entitäten des Typs B erzeugen, und eine des Typs A, um sicherzustellen, dass alle
  	Fälle für diese Beziehung abgedeckt sind. Die Beziehung 1..1:0..1 ist symmetrisch zu dieser.
  	

  	\subsubsection{0..1:0..1}
  	
  	Wenn für beide Entitätstypen die Beziehung optional ist, muss der Generator jeweils mindestens 2 Entitäten erzeugen. Jeweils
  	eine Entität ohne Beziehung und jeweils eine Entität mit einer Beziehung (siehe Abbildung \ref{img:generierung:01to01}).

  	\begin{figure}[htbp]
  	  \centering
  	   \includegraphics[width=0.55\textwidth]{images/generierung/0-1-to-0-1.png}
  	  \caption{Beziehungen nach dem Schema 0..1:0..1}\label{img:generierung:01to01}
  	\end{figure}

  \subsection{Kategorie der 1:n-Beziehungen}
  
  Eine Entität steht in Beziehung mit keiner oder mehreren anderen Entitäten. Dabei kann die Anzahl begrenzt sein (konkreter
  Wert für n) oder unbegrenzt. Der Generator kann nur eine begrenzte Anzahl von Entitäten erzeugen, die Grenze sollte
  konfigurierbar sein.
  
  	\subsubsection{1..1:1..n}
  	
  	Die einfachste Form der 1:n-Beziehungen. Eine Entität des Typs A ist in einer Beziehung mit einer oder mehreren Entitäten
  	des Typs B. Eine Entität des Typs B ist mit genau einer Entität des Typs A in Beziehung.

  	\begin{figure}[htbp]
  	  \centering
  	   \includegraphics[width=0.55\textwidth]{images/generierung/1-1-to-1-n.png}
  	  \caption{Beziehungen nach dem Schema 1..1:1..n}\label{img:generierung:11to1n}
  	\end{figure}

  	\subsubsection{0..1:1..n}
  	
  	Eine Entität des Typs A steht in Beziehung mit einer oder mehreren Entitäten des Typs B. Eine Entität des Typs B steht
  	entweder mit genau einer oder mit keiner Entität des Typs A in Beziehung. 

  	\begin{figure}[htbp]
  	  \centering
  	   \includegraphics[width=0.55\textwidth]{images/generierung/0-1-to-1-n.png}
  	  \caption{Beziehungen nach dem Schema 0..1:1..n}\label{img:generierung:01to1n}
  	\end{figure}
  	
  	\subsubsection{1..1:0..n}
  	
  	Eine Entität des Typs A steht in Beziehung mit keiner, einer oder mehreren Entitäten des Typs B. Eine Entität des Typs B
  	muss mit genau einer Entität des Typs A in Beziehung stehen.

  	\begin{figure}[htbp]
  	  \centering
  	   \includegraphics[width=0.55\textwidth]{images/generierung/1-1-to-0-n.png}
  	  \caption{Beziehungen nach dem Schema 1..1:0..n}\label{img:generierung:11to0n}
  	\end{figure}



  	\subsubsection{0..1:0..n}
		
		Eine Entität des Typs A steht mit keiner, einer oder mehreren Entitäten des Typs B in Beziehung. Eine Entität des Typs B
		kann mit keiner oder genau einer Entität des Typs A in Beziehung stehen.

  	\begin{figure}[htbp]
  	  \centering
  	   \includegraphics[width=0.55\textwidth]{images/generierung/0-1-to-0-n.png}
  	  \caption{Beziehungen nach dem Schema 0..1:0..n}\label{img:generierung:01to0n}
  	\end{figure}

  \subsection{Kategorie der n:m-Beziehungen}
	\label{sec:generieren:beziehungen:nm}
		
	Die allgemeinste Form einer Beziehung zwischen zwei Eintitätstypen stellt eine n..N:m..M-Beziehung dar. Dabei handelt es
	sich bei n und m jeweils um untere und bei N und M jeweils um obere Schranken. Untere und obere Schranken können
	identisch sein.
	
	Jede der in diesem Abschnitt beschriebenen Beziehungsformen stellen Spezialfälle von n:m-Beziehungen dar, bei denen
	eine oder beide oberen Schranken 1 sind. Sind beide obere Schranken größer als 1, dann wird eine solche Beziehung
	üblicherweise über assoziative Tabellen realisiert.
	


\section{Komplexität bei der Generierung von Beziehungen}
\label{sec:generieren:komplexitaet}

Im vorausgegangenen Abschnitt wurden nur Beziehungen zwischen zwei Entitätstypen betrachtet. In realen Anwendungen können
Entitätstypen mit mehr als nur einem anderen Entitätstyp in Beziehung stehen und auch mit dem selben Entitätstyp mehr als
nur ein Mal.

Bezüglich der Datengenerierung lassen sich hierbei zwei generelle Vorgehensweisen lassen sich hier unterscheiden:
\begin{itemize}
	\item \textbf{Beziehungen unabhängig betrachten}: Es wird angenommen, dass unterschiedliche Beziehungen voneinander
	  unabhängig sind. Die Frage, ob ein Professor eine Lehrveranstaltung leitet, lässt keine Rückschlüsse zu, ob und welche
		Prüfungen er beaufsichtigt.
	
	\item \textbf{Beziehungen abhängig voneinander betrachten}: In der Praxis beeinflussen sich Beziehungen. Ein Student,
	  der die Prüfung einer Lehrveranstaltung schreibt, darf wohl nicht gleichzeitig Tutor dieser Veranstaltung sein.
	
\end{itemize}

Alle Beziehungen abhängig voneinander zu betrachten kann schnell zu exponentiell zunehmenden Testdaten führen. 
Einen riesigen Bestand an Daten um für Tests unnötige Beziehungen und schließlich auch Entitäten zu verringern
scheint aufwändiger, als einen kleinen Datenbestand um fehlende Beziehungen punktuell zu erweitern. Aus diesem Grund
berücksichtigt der Algorithmus keine Beziehungen in Abhängigkeit von anderen -- mit Ausnahme von assoziativen
Tabellen.

\section{Algorithmus zur Generierung von Beziehungen}
\label{sec:generieren:algorithmus}

In \cite{Houkjaer:2006:SRD:1182635.1164254} wird ein Algorithmus zur Generierung von Test-Daten vorgestellt, der
das Datenbank-Modell als Graphen betrachtet. Auch dieser Algorithmus ist eher für die Erzeugung von Massen-Daten geeignet.
Der entwickelte Algorithmus übernimmt die Idee, das Modell als Graphen zu betrachten.

Die Beschreibung des Algorithmus verwendet einige Begriffe und Konventionen, die im Folgenden beschrieben werden.

	\subsection{Begriffserklärungen}
	
  	
	
		\subsubsection{Knoten und Kanten}
		
		Die Idee, das Datenbank-Modell als Graphen zu betrachten, stammt aus \cite{Houkjaer:2006:SRD:1182635.1164254}. 
		Tabellen stellen die Knoten des Graphs dar. Die Foreign-Key-Beziehungen zwischen zwei Tabellen stellen die Kanten
		des Graphs dar. Eine Kante ist gerichtet, von der Tabelle mit der Foreign-Key-Spalte zur referenzierten Tabelle hin.
		Aufgrund der Richtung hat jede Kante eine Start- und eine Zieltabelle.
		
		Auch wenn es gerichtete Kanten sind, ist eine Traversierung in beide Richtungen möglich.
		
	
		\subsubsection{Assoziative Tabellen}
		
		Assoziative Tabellen verbinden zwei Tabellen. Die beiden verbundenen Tabellen werden schlicht als linke und rechte
		Tabelle bezeichnet, analog wird von linker und rechter Kante gesprochen.
		
		Die Reihenfolge, in der die Spalten der Tabelle definiert sind, bestimmt die Einteilung in links und rechts. Der erste
		Fremdschlüssel referenziert die linke Tabelle. Das Ergebnis der Generierung hängt nicht von dieser Einteilung ab.
	

  \subsection{Pseudocode}
  \label{sec:generieren:algorithmus:pseudocode}
	
		\subsubsection{Generiere Test-Daten}
		
		Die Funktion \texttt{Generiere\_Test\_Daten} (siehe Listing \ref{listing:GeneriereTestDaten}) ist der Einstiegspunkt
		für den Algorithmus zur Generierung von Test-Daten.
		Im ersten Schritt wird die Reihenfolge der Tabellen festgelegt, die als Startpunkte in Frage kommen. Die Liste
		stellt sicher, dass auch Datenbank-Modelle, die aus mehreren unabhängigen Graphen bestehen, vollständig
		generiert werden. In einem Datenbank-Modell, in dem alle Tabellen direkt oder indirekt in Beziehung stehen,
		würde die Festlegung einer Starttabelle ausreichen.
		
		Zur Sortierung der Tabellen wird die Anzahl eingehender Kanten verwendet. Der Grund dafür und die Bedeutung der
		Reihenfolge der Tabellen wird in Abschnitt \ref{sec:generieren:evaluation:tabellenreihenfolge} beschrieben.
		
		Anschließend wird über diese Tabellenliste iteriert. Wurde eine Tabelle noch nicht behandelt, wird die
		entsprechende Funktion zur Generierung der Daten aufgerufen. Dabei werden nicht-assoziative und
		assoziative Tabellen unterschiedlich behandelt. Der Grund dafür ist, dass assoziative Tabellen ein
		Hilfskonstrukt darstellen, das selbst eine Beziehung auf ER-Ebene darstellt.
		
		Am Ende stellt der Algorithmus sicher, dass jede Entität gültig generiert wurde, also dass die Beziehungen
		die Constraints erfüllen. Gegebenenfalls werden hier Entitäten nach generiert.
  
\begin{lstlisting}[caption=Generiere Test-Daten, label=listing:GeneriereTestDaten]
GeneriereTestDaten
------------------
L := Tabellenliste, nach Anzahl eingehender Kanten aufsteigend geordnet
FOR EACH (noch nicht besuchte Tabelle T IN der geordneten Tabellenliste L)
DO
  Markiere Tabelle T als besucht;
  IF (Tabelle T ist keine assoziative Tabelle)
  THEN CALL Generiere_Daten_Fuer_Nichtassoziative_Tabelle(T);
  ELSE CALL Generiere_Daten_Fuer_Assoziative_Tabelle(T);
  END IF;
END FOR;
CALL "ErweitereGenerierteDatenzuKonsistenenDaten"()
\end{lstlisting}

		\subsubsection{Generiere Daten für nichtassoziative Tabelle}
		
		Der Generator betrachtet zur Generierung von Entitäten die Beziehungen der Tabellen. Aus diesem Grund
		erzeugt die Funktion \texttt{Generiere\_Daten\_Fuer\_Nichtassoziative\_Tabelle}
		(siehe Listing \ref{listing:GeneriereDatenFuerNichtassoziativeTabelle})
		selbst keine Daten. Stattdessen werden die (noch unbehandelten) Kanten der Tabelle betrachtet. 
		
		Handelt es sich bei der an der Beziehung beteiligten Tabelle um eine assoziative Tabelle, wird mit der
		Generierung der assoziativen Beziehungen fortgesetzt. Ansonsten wird die Funktion zur Generierung der
		Daten für eine Kante aufgerufen.
		
	  Der Algorithmus aus \cite{Houkjaer:2006:SRD:1182635.1164254} bevorzugt ausgehende Kanten bei der Erzeugung
		von Daten, da sich diese mit weniger Aufwand abarbeiten lassen. Diese Bevorzugung wird für den hier
		entwickelten Algorithmus übernommen, auch wenn sich der Aufwand für ein- und ausgehende Kanten nicht
		unterscheidet.

\begin{lstlisting}[caption=GeneriereDatenFuerNichtassoziativeTabelle, label=listing:GeneriereDatenFuerNichtassoziativeTabelle]
Generiere_Daten_Fuer_Nichtassoziative_Tabelle(Tabelle T)
---------------------------------------------------
FOR EACH (ausgehende Kante K, die noch nicht besucht wurde)
DO
  IF (Zieltabelle Z von Kante K ist keine assoziative Tabelle)
  THEN Markiere Kante K als besucht;
       CALL Generiere_Daten_Fuer_Kante(K);
			 IF (Zieltabelle Z noch nicht besucht) 
			 THEN Markiere Tabelle Z als besucht;
            CALL Generiere_Daten_Fuer_Nicht_Assoziative_Tabelle(Z);
			 END IF;
  ELSE CALL Generiere_Daten_Fuer_Assoziative_Tabelle(Z);
  END IF;
END FOR;
FOR EACH (eingehende Kante K, die noch nicht besucht wurde)
DO
  IF (Starttabelle S von Kante K ist keine assoziative Tabelle)
  THEN Markiere Kante K als besucht;
       CALL Generiere_Daten_Fuer_Kante(K);
			 IF (Starttabelle S noch nicht besucht) 
			 THEN Markiere Tabelle S als besucht;
            CALL Generiere_Daten_Fuer_Nicht_Assoziative_Tabelle(S);
			 END IF;
  ELSE CALL Generiere_Daten_Fuer_Assoziative_Tabelle(S);
  END IF;
END FOR;
\end{lstlisting}

		\subsubsection{Generiere Daten für Kante}
		
		Die Funktion zum Generieren von Daten für eine Kante setzt die führt die 
		\ref{sec:generieren:beziehungen:nm} beschriebenen Schritte um. Es werden alle vier Kombinationen aus
		Minimum und Maximum behandelt. Die eigentliche Generierung findet ist in eine Hilfsfunktion ausgelagert,
		die mit allen Min-Max-Kombinationen aufgerufen wird.

\begin{lstlisting}[caption=Generiere Daten Fuer Kante, label=listing:GeneriereDatenFuerKante]
Generiere_Daten_Fuer_Kante(Kante K)   
------------------------------
S := Starttabelle von Kante K;
Z := Zieltabelle von Kante K;
// Generierung der Daten entsprechend Abschnitt 6.2.3 bzw. 6.2.4
CALL Generiere_Entitaeten_Und_Beziehungen(K, min(S), min(Z));
CALL Generiere_Entitaeten_Und_Beziehungen(K, min(S), max(Z));
CALL Generiere_Entitaeten_Und_Beziehungen(K, max(S), min(Z));
CALL Generiere_Entitaeten_Und_Beziehungen(K, max(S), max(Z));
\end{lstlisting}

		\subsubsection{Generiere Entitäten und Beziehungen}
		
		Es soll vermieden werden, unnötige Entitäten und Beziehungen zu generieren. Unnötig sind vor allem
		redundante Beziehungen, die beispielsweise entstehen, wenn die untere und obere Grenze einer
		Multiplizität identisch sind. Deshalb wird für jede Kombination aus Kante, Anzahl der beteiligten Entitäten
		der Starttabelle und Anzahl der beteiligten Entitäten der Zieltabelle die Generierung nur ein einziges
		Mal durchgeführt.
		
		Der Algorithmus prüft, ob es sich um eine optionale Beziehung handelt. Eine der Grenzen s bzw. z
		ist in einem solchen Fall gleich 0. Handelt es sich um eine optionale Beziehung, wird eine entsprechende
		Entität berechnet, die in Bezug auf die Kante in keiner Beziehung ist. Anschließend wird die Funktion
		rekursiv aufgerufen, diesmal mit dem Wert 1 als Grenze anstelle der 0.
		
		Sofern s und z beide ungleich 0 sind, wird eine Entität in der Zieltabelle berechnet und s Entitäten 
		in der Starttabelle. Zwischen diesen Entitäten wird die von der Kante K repräsentierte Beziehung
		hergestellt.
		
		Der Eingangswert z kann aufgrund der Tatsache, dass es sich um eine nicht-assoziative Tabelle handelt,
		nur 0 oder 1 sein.
		
\begin{lstlisting}[caption=Generiere Entitäten Und Beziehungen, label=listing:GeneriereEntitaetenUndBeziehungen]
Generiere_Entitaeten_Und_Beziehungen(K, s, z)
-----------------------------------------
// Sicherstellen, dass nicht mehr Entitäten als notwendig erzeugt werden
IF (Für die Kombination (K, s, z) wurden bereits Entitäten erzeugt) 
THEN RETURN;
END IF
IF (Wert der Grenze s ist 0)
THEN Berechne Entität e in Zieltabelle, die in keiner Beziehung zur Starttabelle stehen darf;
     CALL Generiere_Entitaeten_Und_Beziehungen(k, 1, z);
ELSE IF (Wert der Grenze z ist 0)
THEN Berechne Entität e in Starttabelle, die in keiner Beziehung zur Zieltabelle stehen darf;
     CALL Generiere_Entitaeten_Und_Beziehungen(k, s, 1);
ELSE // z ist hier immer 1
     Berechne Entität e in Zieltabelle, die in keiner Beziehung zur Starttabelle stehen darf;
		 FOR i = 1 TO s
		 DO 
       Berechne Entität se in Starttabelle, die in keiner Beziehung zur Zieltabelle stehen darf;
		   Stelle Beziehung zwischen Entität se und Entität e her;
		 END FOR;
END IF;
\end{lstlisting}

		\subsubsection{Generiere Daten für assoziative Tabelle}
		
		Assoziative Tabellen werden typischerweise zur Modellierung von n..N:m..M-Beziehungen verwendet. Diese Beziehungen
		werden entsprechend der in Abschnitt \ref{sec:generieren:beziehungen:nm} beschriebenen Strategie generiert. D.h. es
		werden alle vier Kombinationen aus den jeweiligen Minimal- und Maximalwerten betrachtet.
		
		Nach der Erzeugung der Daten für die assoziative Tabelle versucht der Algorithmus, die Generierung bei den beiden
		assoziierten Tabellen fortzusetzen -- falls diese noch nicht behandelt wurden.

\begin{lstlisting}[caption=Generiere Daten für assoziative Tabelle, label=listing:GeneriereDatenFuerAssoziativeTabelle]
Generiere_Daten_Fuer_Assoziative_Tabelle(Tabelle T)
-----------------------------------------------
LK := linke Kante der assoziativen Tabelle T;
RK := rechte Kante der assoziativen Tabelle T;
markiere Kanten LK und RK als besucht;
LM := Multiplizität der linken Beziehung, ausgehende Seite
RM := Multiplizität der rechten Beziehung, ausgehende Seite
CALL Generiere_Assoziative_Entitaeten_Und_Beziehungen(T, min(LM), min(RM));
CALL Generiere_Assoziative_Entitaeten_Und_Beziehungen(T, min(LM), max(RM));
CALL Generiere_Assoziative_Entitaeten_Und_Beziehungen(T, max(LM), min(RM));
CALL Generiere_Assoziative_Entitaeten_Und_Beziehungen(T, max(LM), max(RM));
LT := Zieltabelle von Kante LK;
RT := Zieltabelle von Kante RK;
IF (LT wurde noch nicht besucht)
THEN Markiere Tabelle LT als besucht;
     IF (Tabelle LT ist keine assoziative Tabelle)
     THEN CALL Generiere_Daten_Fuer_Nichtassoziative_Tabelle(LT);
     ELSE CALL Generiere_Daten_Fuer_Assoziative_Tabelle(LT);
     END IF;
END IF;
IF (RT wurde noch nicht besucht)
THEN Markiere Tabelle RT als besucht;
     IF (Tabelle RT ist keine assoziative Tabelle)
     THEN CALL Generiere_Daten_Fuer_Nichtassoziative_Tabelle(RT);
     ELSE CALL Generiere_Daten_Fuer_Assoziative_Tabelle(RT);
     END IF;
END IF;
\end{lstlisting}

		\subsubsection{Generiere assoziative Entitäten und Beziehungen}
		
		- Unbedingt Parameter l und r beschreiben
		
		- Kombination (T, LA, RA) erklären

\begin{lstlisting}[caption=Generiere Assoziative Entitaeten Und Beziehungen, label=listing:GeneriereAssoziativeEntitaetenUndBeziehungen]
Generiere_Assoziative_Entitaeten_Und_Beziehungen(T, l, r)
----------------------------------------------------
LK := linke Kante der assoziativen Tabelle T;
RK := rechte Kante der assoziativen Tabelle T;
// Grenzen "tauschen" und Mindestanzahl auf 1
LA := Max(r, 1);  // r als Grenze, mindestens 1
RA := Max(l, 1);  // l als Grenze, mindestens 1
IF (Für die Kombination (T, LA, RA) wurden bereits Entitäten erzeugt) 
THEN RETURN;
END IF
FOR i = 1 TO RA
DO 
  Berechne Entität le[i] in linker Tabelle die in keiner Beziehung zur assoziativen Tabelle T stehen darf;
END FOR;
FOR j = 1 TO LA
DO 
  Berechne Entität re[j] in rechter Tabelle die in keiner Beziehung zur assoziativen Tabelle T stehen darf;
END FOR;
FOR i = 1 TO RA
DO 
  FOR j = 1 TO LA
  DO 
    Erzeuge Entität e in assoziativer Tabelle;
    Stelle Beziehung zwischen Entität e und Entität le[i] her;
	  Stelle Beziehung zwischen Entität e und Entität re[j] her;
  END FOR;
END FOR;
\end{lstlisting}

		\subsubsection{Erweitere Generierte Daten zu konstistenten Daten}

\begin{lstlisting}[caption=ErweitereGenerierteDatenZuKonsistenenDaten, label=listing:ErweitereGenerierteDatenZuKonsistenenDaten]
"ErweitereGenerierteDatenZuKonsistenenDaten"()
-----------------------------------------------
\end{lstlisting}




  \subsection{Beispiel}
	

\section{Praktischer Einsatz / Evaluation}

  \subsection{Einfluss der Tabellenreihenfolge}
	\label{sec:generieren:evaluation:tabellenreihenfolge}
		
	Die Art und Weise, wie Beziehungen generiert werden, hängen von der Reihenfolge ab, in der die Tabellen und Kanten behandelt
	werden. Die gewählte Reihenfolge basiert auf den Kriterien aus \cite{Houkjaer:2006:SRD:1182635.1164254}. Die Sortierung
	wird nicht aus Qualitätsgründen, sondern für ein deterministisches Verhalten des Algorithmus beibehalten.
	
	Empirische Versuche führten zu der Vermutung, dass die Reihenfolge keinen Einfluss auf die Anzahl der generierten Entitäten hat.
	Auf einen Beweis dafür wird an dieser Stelle verzichtet, da es weniger wichtig ist, die tatsächlich minimale Anzahl an Entitäten
	zu generieren. Viel wichtiger ist, dass gültige DataSets generiert werden.

\section{Konkrete Implementierung und Integration in Toolset}

Die Integration des Daten-Generators führt zu generierungsspezifischen Erweiterungen im Datenbank-Modell. So kann für jede Spalte
individuell ein Werte-Generator festgelegt werden -- ansonsten wird ein Standard-Werte-Generator für den jeweiligen Datentyp verwendet.

Die Zufallszahlengeneratoren der Werte-Generatoren werden über Seeds initialisiert. Damit der selbe Werte-Generator für verschiedene
Spalten standardmäßig unterschiedliche Werte erzeugt, wird der Standard-Spalten-Seed mit Hilfe des Tabellen- und des Spaltennamen
berechnet. Es ist außerdem möglich, tabellenspezifische Seeds und ein modellspezifisches Seed festzulegen, die jeweils den Standardwert
0 haben. Das tatsächliche Seed, mit dem die Zufallsgeneratoren initialisiert werden, stellt die Summe aus dem Spalten-Seed,
dem Tabellen-Seed und dem Modell-Seed dar.

Auf diese Weise kann über Seeds verhältnismäßig einfach gesteuert werden, dass nur eine Spalte mit neuen Zufallswerten generiert wird, 
alle Spalten einer Tabelle oder alle Spalten aller Tabellen. Es ist darüber hinaus auch möglich, zwei Spalten mit selben Zufallswerten
zu erzwingen.

Da der Daten-Generator die Anzahl zu erzeugender Entitäten über die Beziehungen bestimmt, würde eine Tabelle ohne eine Beziehung zu anderen
Tabellen leer bleiben. Das Modell wird deshalb für jede Tabelle um einen Wert erweitert, der Mindestanzahl der zu generierenden Entitäten
enthält. Der Standardwert dafür ist 1.

\todo{Code Listing verknüpfen, infinite beschreiben}

\begin{lstlisting}[caption=Ausschnitt des für die Daten-Generierung erweiterten Modells, label=listing:modell:ausschnittfuergenerierung]
public HochschuleModel()
{
  database("Hochschule");
  packageName("com.seitenbau.testing.hochschule.model");
  enableTableModelClassesGeneration();
  seed(0);
  infinite(2);

  Table raum = table("raum")
      .description("Die Tabelle mit den Räumen der Hochschule")
      .seed(0)
      .minEntities(20)
      .column("id", DataType.BIGINT)
        .defaultIdentifier()
        .autoInvokeNext()
      .column("gebaude", DataType.VARCHAR)
      .column("nummer", DataType.VARCHAR)
    .build();
  
	...
}
\end{lstlisting}

\section{Offene Punkte}

- Abhängigkeiten von Beziehungen

- Abhängigkeiten von Spaltendaten (und Beziehungen?)

    \begin{figure}[htbp]
  	  \centering
  	   \includegraphics[width=0.55\textwidth]{images/generierung/infinite.png}
  	  \caption{Unerfüllbar}\label{img:generierung:offen:infinite}
  	\end{figure}
