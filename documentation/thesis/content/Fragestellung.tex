\chapter{Anforderungsanalyse}
\label{chap:anforderungen}

In diesem Kapitel werden die Anforderungen an die zu entwickelnde Lösung konkretisiert. Es
beinhaltet Bewertungen von bestehenden Modellierungssprachen. Für diesen Vergleich 
werden Kriterien für die Bewertung der Sprache definiert und ein Datenbank-Modell vorgestellt,
das als fortlaufendes Beispiel dient und auch in den folgenden Kapiteln verwendet wird.

\section{Allgemeine Anforderungen}
\label{sec:anforderungen:allgemeineanforderungen}

Die Hauptziele dieser Arbeit stellen sich wie folgt dar:
\begin{enumerate}
	\item Vereinfachen der Beschreibung von Beziehungen
	\item Modellierte Testdaten übersichtlicher machen
	\item Automatisches Generieren von Testdaten
\end{enumerate}


Für die Modellierung gelten diese allgemeinen Anforderungen:

\begin{itemize}
	\item \textbf{Integration in bestehende Werkzeugkette}: Die Lösung sollte sich nach Möglichkeit in die bestehende
	  Werkzeugkette von SEITENBAU integrieren lassen.  
		
  \item \textbf{IDE-Integration}: Bedienbarkeit für den Tester stellt eine der wichtigsten Anforderungen dar. Daten sollen
	  komfortabel modelliert werden können. Die Integration in Entwicklungsumgebungen wie Eclipse oder IntelliJ IDEA muss
		gegeben sein. 
	
	\item \textbf{Beziehungen}: Beziehungen sollen einfach modelliert werden können. 

	\item \textbf{Veränderbarkeit von DataSets}: DataSets sollen sich während der Modellierung beliebig verändern lassen.
	
	\item \textbf{Komposition}: DataSets sollen sich aus anderen DataSets zusammensetzen lassen.
	
	\item \textbf{Typ-Sicherheit}: Die Beschreibung der Daten sollte typsicher erfolgen. Idealerweise sollten falsche
	  Typen schon während des Kompilierens erkannt werden.
		
	\item \textbf{Funktionen als Werte}: Es soll möglich sein, Hilfsfunktionen zur Berechnung von Werten zu verwenden,
	  z.B. zum Einlesen von Binary Large Objects (BLOBs) aus Dateien.
		
	\item \textbf{Zielgruppe}: Die Zielgruppe für die DSL sind Software-Entwickler und Tester. Der Code zur Modellierung
	  der Daten sollte auch für andere Projekt-Mitglieder lesbar und verständlich sein.

	\item \textbf{Ungültige Daten}: Es sollen sich auch aus Sicht der Datenbank oder des SUT ungültige Daten modellieren lassen.

\end{itemize}


Für die Generierung der Testdaten lassen sich die Anforderungen folgendermaßen zusammenfassen:
\begin{itemize}

  \item \textbf{Gültige Daten}: Die erzeugten Daten müssen gültig sein und zum Datenbank-Schema passen.
	
	\item \textbf{Mehrfach verwendbare Daten}: Die generierten Daten sollen für verschiedene Tests verwendet werden können,
	  also ein Standard-Fixture darstellen. Die Daten müssen deshalb viele Test-Fälle abdecken können.
  
	\item \textbf{Fokus auf Beziehungen}: Das Generieren von sinnvollen Beziehungen stellt eines der zentralen Ziele für
	  den Daten-Generator dar.
	
	\item \textbf{Datenmenge selbst bestimmen}: Der Generator soll ohne Konfigurationsaufwand eine geeignete Menge an Testdaten
	  erzeugen.

	\item \textbf{Deterministische Generierung}: Auch wenn die Testdaten aus Zufallsdaten bestehen, sollen sie deterministisch
	  generiert werden können. Das heißt, dass die Generierung des Modells mit denselben Einstellungen auch zum selben Ergebnis
		führt.
		
	\item \textbf{Kompatibilität}: Die Generierung der Testdaten soll in unterschiedliche Ausgabe-Formen erfolgen können,
	  z.B. in einer DSL, in XML oder auch in SQL-Statements.
	
\end{itemize}


\section{Modellierungskonzepte für Beziehungen}
\label{sec:fragestellung:modellierungskonzepte}
	
Je nach Beziehungsart gibt es unterschiedliche Ansätze, wie diese in einem ER-Diagramm umgesetzt werden können.
Dabei können neben den Entitäten auch die Beziehungen selbst Attribute haben.
Die folgenden drei grundsätzlichen binären Beziehungsarten (also zwischen zwei Entitätstypen) werden dabei unterschieden:

	\subsection{1:1-Beziehungen}
	\label{sec:fragestellung:onetoone}
	
	Eine binäre Beziehung zwischen zwei Entitätstypen, wobei jede Entität innerhalb dieser Beziehung maximal einer
	anderen Entität zugeordnet sein kann. Eine solche Beziehung kann realisiert werden, indem eine Tabelle um einen
	Fremdschlüssel auf die andere erweitert wird. Dabei sollten der Fremdschlüssel und auch die beziehungsbeschreibenden
	Attribute immer der Tabelle hinzugefügt werden, deren Entitäten eine Beziehung voraussetzt.
	
	Wenn viele Beziehungsattribute vorhanden sind oder die Beziehung auf beiden Seiten optional ist,
	kann es auch sinnvoll sein, eine 1:1-Beziehung wie eine n:m-Beziehung zu modellieren.

	\subsection{1:n-Beziehungen}
	\label{sec:fragestellung:onetomany}

	Eine binäre Beziehung zwischen zwei Entitätstypen, wobei jede Entität des einen Typs in Beziehung mit mehreren
	Entitäten des anderen Typs stehen kann. Diese Entitäten können auch nur mit maximal einer Entität in Beziehung
	stehen. Es ist möglich festzulegen, wie viele Beziehungen eine Entität mindestens und höchstens haben darf.
	
	Die Tabelle der Entitäten, die maximal einer anderen Entität zugeordnet sind, wird um einen Fremdschlüssel
	und um für jede Beziehung individueller Attribute erweitert. Die Beziehungsattribute, die für alle Beziehungen
	der beteiligten Entität gelten, werden ihrer Tabelle hinzugefügt.
	
	\subsection{n:m-Beziehungen}
	\label{sec:fragestellung:manytomany}
	
	Eine binäre Beziehung zwischen zwei Entitätstypen, wobei jede Entität des einen Typs mit mehreren Entitäten
	des anderen Typs in Beziehung stehen kann -- und umgekehrt. Es ist möglich, untere und obere Grenzwerte für
	die Anzahl der Beziehungen auf beiden Seiten festzulegen. Solche als assoziativ bezeichneten Beziehungen
	werden über eine Hilfstabelle modelliert, die assoziative Tabelle genannt wird. Diese besteht
	aus den beiden Fremdschlüsseln auf die beteiligten Tabellen und den beziehungsbeschreibenden Attributen.
	
	Grundsätzlich können assoziative Tabellen für alle binären Beziehungen verwendet werden. Vor allem wenn 
	die Beziehung viele Attribute enthält, kann eine assoziative Tabelle für übersichtlichere Tabellenstrukturen
	sorgen.  

	\subsection{Andere Beziehungen}
	\label{sec:fragestellung:anderebeziehungen}
	
	In der aktuellen \textit{STU}-Implementierung müssen andere Beziehungen manuell umgesetzt werden. Dies gilt
	für zirkuläre, für reflexive und für alle nicht-binären Beziehungen.



\section{Fortlaufendes Beispiel}
\label{sec:fragestellung:beispiel}

% Beispiel einleiten
Ein einheitliches fortlaufendes Beispiel soll der Arbeit als Grundlage dienen. Die Problemstellung besteht aus
einem Modell und einer Menge von Testdaten. Diese Testdaten dienen als Grundlage für die Diskussion der unterschiedlichen
Modellierungsvarianten.

	\subsection{Anforderungen an das Beispiel}
	\label{sec:fragestellung:beispiel:voraussetzungen}

	Der Schwerpunkt der Modellierung liegt bei der Darstellung von Beziehungstypen zwischen Entitätstypen. Dabei soll die
	Problemstellung einerseits nicht zu komplex sein, damit sie überschaubar bleibt. Andererseits soll sie komplex genug
	sein, um möglichst alle Beziehungsarten zwischen Entitäten abzudecken.
	Die Testdaten sollten gleichzeitig ein \textit{Standard Fixture} und ein \textit{Minimal Fixture} darstellen
	(\refsec{sec:grundlagen:konzepte:tests}).
	

	\subsection{Gewählte Problemstellung}
	\label{sec:fragestellung:beispiel:gewaehlte_problemstellung}
	Das gewählte Beispiel stellt eine starke Vereinfachung des Prüfungswesens an Hochschulen dar. Auf eine praxisnahe
	Umsetzung wird zugunsten der Komplexität verzichtet. Personenbezogene Begriffe werden in der maskulinen Form verwendet,
	ohne dabei Aussagen über das Geschlecht der repräsentierten Personen zu machen. Es beinhaltet die folgenden fünf 
	Entitätstypen:

	\begin{itemize}
		\item \textbf{Professor}: Ein Professor leitet Lehrveranstaltungen.
		\item \textbf{Lehrveranstaltung}: Eine Lehrveranstaltung wird von einem Professor geleitet. Es kann zu jeder
			Lehrveranstaltung eine Prüfung geben.
		\item \textbf{Prüfung}: Eine Prüfung ist einer Lehrveranstaltung zugeordnet. Außerdem hat mindestens ein Professor
			Aufsicht.
		\item \textbf{Student}: Studenten können an Lehrveranstaltungen und an Prüfungen teilnehmen. Studenten haben außerdem 
			die Möglichkeit, Tutoren von Lehrveranstaltungen zu sein.
		\item \textbf{Raum}: Ein Professor kann einen Raum als Büro zugewiesen bekommen.
	\end{itemize}
	
	Die Beziehungen der Entitätstypen stellen sich wie folgt dar: 
	\begin{itemize}
		\item \textbf{leitet}: Eine Lehrveranstaltung muss von genau einem Professor geleitet werden, ein Professor kann beliebig viele
		  oder keine Lehrveranstaltungen leiten.
		\item \textbf{geprüft}: Eine Prüfung ist genau einer Lehrveranstaltung zugeordnet. Eine Lehrveranstaltung kann mehrere Prüfungen 
		  haben (z.B. Nachschreibprüfung).
		\item \textbf{beaufsichtigt}: Eine Prüfung muss mindestens von einem Professor beaufsichtigt werden, ein Professor kann in 
		  beliebig vielen Prüfungen Aufsicht haben. 
		\item \textbf{besucht}: Jeder Student kann beliebig viele Lehrveranstaltungen besuchen. Lehrveranstaltungen benötigen jedoch 
		  mindestens drei Besucher um stattzufinden und sind aus Kapazitätsgründen auf 100 Teilnehmer begrenzt.
		\item \textbf{ist Tutor}: Jeder Student kann bei beliebig vielen Lehrveranstaltungen Tutor sein und jede Lehrveranstaltung
			kann beliebig viele Tutoren haben. 
		\item \textbf{schreibt}: Jeder	Student kann an beliebig vielen Prüfungen teilnehmen und umgekehrt eine Prüfung von einer
		  beliebigen Anzahl von Studenten geschrieben werden.
		\item \textbf{hat Büro}: Jeder Professor hat ein Büro. Ein Raum kann einem oder keinem Professor zugeordnet sein.
	\end{itemize}

	Abbildung \ref{img:example_er} zeigt das Beispiel grafisch in Form eines ER-Diagramms. Den verschiedenen Entitätstypen
	werden dabei Attribute zugeordnet. 
	
	\begin{figure}[H]
		\centering
		 \includegraphics[width=0.60\textwidth]{images/fragestellung/example_hochschule_er.pdf}
		\caption{ER-Diagramm des fortlaufenden Beispiels}\label{img:example_er}
	\end{figure}

	Das entsprechende relationale Datenbank-Schema wird in Abbildung \ref{img:example_relational} dargestellt. 
	Assoziative Tabellen realisieren die n:m-Beziehungen.
	
	\begin{figure}[H]
		\centering
		 \includegraphics[width=0.90\textwidth]{images/fragestellung/example_hochschule_relational.pdf}
		\caption{Relationales Datenbank-Schema des fortlaufenden Beispiels}\label{img:example_relational}
	\end{figure}

	Das Attribut "`fakultaet"' in der Tabelle Professor soll als Aufzählungstyp (enumeration) realisiert werden.
	Mögliche Werte sind: Architektur, Bauingenieurwesen, Elektrotechnik, Informatik, Maschinenbau und Wirtschaftswesen.
	Das Foto des Professors wird als BLOB dargestellt.
	\nomenclature{BLOB}{Binary Large Object)}
	
	Im folgenden Abschnitt werden verschiedene Modellierungsvarianten für DbUnit auf Grundlage dieses Beispiels betrachtet 
	und bewertet.


\section{Modellierungsvarianten der Testdaten für DbUnit}
\label{sec:fragestellung:modellierung}
	
	In \textit{DbUnit} werden die Datenbankzustände durch DataSets repräsentiert. Für einen Test werden gewöhnlich zwei
	DataSets benötigt: das erste für den Anfangszustand, das zweite für den erwarteten Zustand. Allerdings bieten
	DbUnit-DataSets nur begrenzte Möglichkeiten (z.B. kein Löschen von Zeilen aus einem DataSet möglich), das DataSet
	mit dem erwarteten Zustand aus dem DataSet mit dem Anfangszustand zu erzeugen.

	Im Folgenden werden verschiedene Modellierungsarten für DbUnit-DataSets diskutiert. Diese soll anhand der im
	nächsten Abschnitt beschriebenen Kriterien erfolgen. Die Ergebnisse stellen die Grundlage
	für die konkretere Zielsetzung dar.

	\subsection{Kriterien für Bewertung}
	\label{sec:fragestellung:modellierung:sprachkriterien}
	
	Für die Bewertung von Modellierungssprachen werden die folgenden Kriterien verwendet. Einige Punkte
	sind messbar, andere wiederum relativ subjektiv. Als Vorbild für die beiden letzten Punkte dient die
	Norm ISO IEC 9126. 

	\begin{itemize}

		\item \textbf{Zeilen}: Die Anzahl der Zeilen, die für ein DataSet benötigt werden. 
		
		\item \textbf{Zeichen pro Zeile}: Ist die Sprache für die Darstellung auf Bildschirmen geeignet?
		
		\item \textbf{Typsicherheit}: Wann und wie werden falsche Datentypen bei der Modellierung erkannt?
		
		\item \textbf{Redundanz}: Müssen Daten oder Sprachelemente redundant verwendet werden?

		\item \textbf{Benutzbarkeit (Verständlichkeit und Erlernbarkeit)}: 
		  Wie gut drückt die Sprache aus, welche Daten und Beziehungen modelliert werden? Wie leicht
			ist die Sprache zu lernen?
		
		\item \textbf{Modifizierbarkeit}: Wie leicht lassen sich Daten ändern? Wie leicht können
		  bestehende Daten an ein neues Datenbankschema angepasst werden?

	
	\end{itemize}


	\subsection{XML-DataSet}
	\label{sec:fragestellung:modellierung:xml}
	
	Eine Möglichkeit, ein DataSet für DbUnit zu modellieren, stellt XML dar. DbUnit selbst bietet zwei Varianten an, DataSets
	über XML zu modellieren.
	
	Die erste Variante stellt das \texttt{XmlDataSet} dar. Diese Klasse liest eine XML-Datei nach einem von DbUnit
	vorgegebenen Dokumententyp ein. Das Listing \ref{listing:xmldataset} zeigt einen Ausschnitt einer solchen XML-Datei,
	in dem die beiden Tabellen \textit{Professor} und \textit{Lehrveranstaltung} definiert werden.
	
	\lstSetXML
	\begin{lstlisting}[caption=XML-DataSet, label=listing:xmldataset]
<!DOCTYPE dataset SYSTEM "dataset.dtd">
<dataset>
    <table name="PROFESSOR">
        <column>id</column>
        <column>name</column>
        <column>vorname</column>
        <column>titel</column>
        <column>fakultaet</column>
        <row>
            <value>1</value>
            <value>Wäsch</value>
            <value>Jürgen</value>
            <value>Prof. Dr.-Ing.</value>
            <value>Informatik</value>
        </row>
        <row>
            <value>2</value>
            <value>Haase</value>
            <value>Oliver</value>
            <value>Prof. Dr.</value>
            <value>Informatik</value>
        </row>
    </table>
    <table name="LEHRVERANSTALTUNG">
        <column>id</column>
        <column>professor_id</column>
        <column>name</column>
        <column>sws</column>
        <column>ects</column>
        <row>
            <value>1</value>
            <value>2</value>
            <value>Verteilte Systeme</value>
            <value>4</value>
            <value>5</value>
        </row>
        <row>
            <value>2</value>
            <value>2</value>
            <value>Design Patterns</value>
            <value>4</value>
            <value>3</value>
        </row>
    </table>
	...
</dataset>
	\end{lstlisting}
	
	Die Bewertung anhand der Kriterien stellt sich für das \texttt{XmlDataSet} wie folgt dar:
	\begin{itemize}

		\item \textbf{Zeilen}: Die XML-Datei mit den Beispiel-Daten umfasst 127 Zeilen. Jede Entität
		  benötigt jeweils eine Zeile pro Attribut und weitere zwei Zeilen für die umschließenden XML-Tags.
		
			DbUnit-konforme XML-Dateien wachsen schnell in vertikaler Richtung und enthalten unter Umständen
			auch viel syntaktischen Overhead. Von den etwas über 40 gezeigten Zeilen enthalten nur 20 Zeilen
			wirkliche Daten oder drücken Beziehungen aus.

		\item \textbf{Zeichen pro Zeile}: Mit maximal 47 Zeichen pro Zeile ist diese Modellierungsvariante
		  in Bezug auf die Breite gut für die Bildschirmdarstellung geeignet.
		
		\item \textbf{Typsicherheit}: 
			Zur Modellierung müssen Meta-Informationen zu den Daten hinterlegt werden. Diese beschränken sich allerdings auf
			die Bezeichnungen der Spalten (Zeilen 4-8 und 25-29). Da weitere Meta-Informationen fehlen, können fehlerhafte
			Datentypen oder Verstöße gegen Datenbank-Constraints erst zur Laufzeit beim Einspielen des DataSets erkannt werden.
		
		\item \textbf{Redundanz}: 
		  Das Modellieren von Beziehungen führt zu Werte-Redundanz. Die konkreten Werte von Primärschlüsseln müssen an anderer
			Stelle als Fremdschlüssel verwendet werden.

		\item \textbf{Benutzbarkeit (Verständlichkeit und Erlernbarkeit)}: 
			Die positiven Eigenschaften bei der Modellierung mit XML sind unter anderem, dass für XML ein breites Angebot an
			Werkzeugen zur Verfügung steht. Diese können über den Dokumententyp prüfen, ob die Datei den Regeln entspricht.
			Der Umgang mit XML-Dateien kann für die Zielgruppe als bekannt angenommen werden.
			
			Die manuelle Pflege von Primär- und Fremdschlüsseln ist unübersichtlich und damit fehleranfällig. Die Value-Tags
			selbst lassen keinen Rückschluss auf die Spalte zu, die sie repräsentieren. Das erschwert die Lesbarkeit.
			
			In Bezug auf Verständlichkeit zeigt die XML-Datei Schwächen: Ohne zusätzliche Kommentare ist eine solche XML-Datei 
			weder leicht zu lesen noch leicht zu pflegen. Auch Beziehungen sollten über Kommentare verdeutlicht werden.
		
			DbUnit unterstützt BLOBs in XML in Form Base64-codierter Daten. Bei größeren Datenmengen leidet die Übersicht unter dem
			Einbetten von BLOBs, nicht nur wegen dem zusätzlichen Platzbedarf aufgrund der Codierung. Spezielle Mechanismen,
			BLOBs aus anderen Dateien einzulesen, bringt DbUnit nicht mit. Solche Funktionen müssen manuell implementiert werden.
			
		\item \textbf{Modifizierbarkeit}: Daten lassen sich relativ leicht ändern -- sofern man die richtige Stelle gefunden
		  hat, was ohne Kommentare nicht immer so leicht ist. Eine solche XML-Datei an ein neues Datenbank-Schema anzupassen
		  kann einfach, aber auch mühsam sein. Das Umbenennen von Spalten ist sehr einfach, das Entfernen oder Hinzufügen 
			von Spalten bei umfangreichen Daten ohne den geschickten Umgang mit Text-Editoren sehr umständlich.
		  
	\end{itemize}
	
	
	Ein großer Nachteil bei der Nutzung von \texttt{XmlDataSet} ist, dass der erwartete Datenbankzustand selbst wieder den 
	kompletten Datenbankbestand umfassen muss. DbUnit erlaubt zwar mehrere DataSets zu einem zusammenzufassen, das Entfernen 
	von Datensätzen ist darüber aber nicht möglich. Mehrere XML-Dateien mit ähnlichen, überwiegend sogar gleichen Daten,
	sorgen für ein hohes Maß an Redundanz. Darüber hinaus sieht DbUnit keinen Mechanismus für die Komposition von XML-DataSets
	auf Modellierungsebene vor, d.h. es geht aus einer solchen XML-Datei nicht hervor, dass sie auf anderen DataSets
	aufbaut und diese erweitert.
	
	
	% Modellieren Assoziativer Tabellen ansprechen?

  Das \texttt{FlatXmlDataSet} stellt die zweite Variante dar. Hierbei gibt es keine
	von DbUnit vorgegebene DTD, da die Tags den Tabellen-Namen entsprechen\footnote{Es ist möglich, eine eigene DTD zu
	definieren.}. Eine solche XML-Datei kommt ohne explizite Meta-Informationen zu den Tabellen aus. Stattdessen stellen sie
	eine Art Sprachelement dar und werden für die Zuweisung der Werte verwendet. In Bezug auf die Meta-Informationen
	ist das \texttt{FlatXmlDataSet} übersichtlicher als das XmlDataSet (\reflst{listing:flatxmldataset}).
  
	\lstSetXML
	\begin{lstlisting}[caption=Flat-XML-DataSet, label=listing:flatxmldataset]
<?xml version='1.0' encoding='UTF-8'?>
<dataset>
    <PROFESSOR id="1" 
        name="Wäsch"
        vorname="Jürgen"
        titel="Prof. Dr.-Ing."
        fakultaet="Informatik" />
    <PROFESSOR id="2" 
        name="Haase"
        vorname="Oliver"
        titel="Prof. Dr."
        fakultaet="Informatik" />
    <LEHRVERANSTALTUNG id="1"
        professor_id="2"
        name="Verteilte Systeme"
        sws="4"
        ects="5" />
    <LEHRVERANSTALTUNG id="2"
        professor_id="2"
        name="Design Patterns"
        sws="4"
        ects="3" />
...
</dataset>
	\end{lstlisting}

	Das \texttt{FlatXmlDataSet} hat große Ähnlichkeit zum \texttt{XmlDataSet}, das zeigt sich auch in
	der Bewertung. Einige vorher genannte Punkte gelten hier weiterhin.
	
	\begin{itemize}

		\item \textbf{Zeilen}: Dieselben Beispieldaten lassen sich hier mit 63 Zeilen ausdrücken. Die Datei
		  kommt mit weniger Meta-Informationen und etwas weniger syntaktischem Ballast aus. Allerdings
		  sollte auch hier jedes Attribut in eine Zeile geschrieben werden.
		
		\item \textbf{Zeichen pro Zeile}: Mit maximal 40 Zeichen pro Zeile für die gewählten Testdaten ist
		  das \texttt{FlatXmlDataSet} für die Bildschirmdarstellung gut geeignet.
		
		\item \textbf{Typsicherheit}: Wie auch beim \texttt{XmlDataSet} können die Typen erst beim
		  Einspielen in die Datenbank überprüft werden.
		  
		\item \textbf{Redundanz}: Es tritt dieselbe Daten-Redundanz wie beim \texttt{XmlDataSet} auf.

		\item \textbf{Benutzbarkeit (Verständlichkeit und Erlernbarkeit)}:
		  Durch die fehlende Hierarchie wirkt das \texttt{FlatXmlDataSet} etwas unübersichtlich. Die
			Spalten-Bezeichner stellen eine Art Sprachelement dar, d.h. sie werden als XML-Attribut-Bezeichner
			bei der Datenzuweisung verwendet. Das ist übersichtlich und verständlich. Außerdem müssen
			die Attribute nicht zwingend in derselben Reihenfolge angegeben werden.
			
		\item \textbf{Modifizierbarkeit}:
		  Das Ändern der Daten wird dadurch erleichtert, dass Spaltennamen und Wert direkt beieinander stehen.
			Ansonsten gelten die bereits für das \texttt{XmlDataSet} genannten Punkte.
	
	\end{itemize}
	


	\subsection{Default-DataSet}
	\label{sec:fragestellung:modellierung:java}
	
	DbUnit erlaubt auch die programmatische Modellierung von DataSets. Dazu stellt es die Klasse \texttt{DefaultDataSet}
	bereit. Mit den Mitteln, die eine Programmiersprache wie Java bietet, lassen sich einige der Nachteile in Verbindung
  mit den XML-basierten DataSets direkt umgehen.
	
	So können Beziehungen mit Hilfe symbolischer Konstanten ausdrucksstärker modelliert werden. Auch wenn die Beziehungen
	immer noch etwas umständlich modelliert werden müssen, können symbolische Konstanten dabei helfen, Redundanz zu vermeiden
	und damit das Risiko für Fehler zu senken, die bei der Änderung solcher Werte auftreten können.

	\lstSetJava
	\begin{lstlisting}[caption=Default-DataSet, label=listing:javadataset]
DefaultTable professor = new DefaultTable(
		"professor",
		new Column[] { 
			new Column("id", DataType.INTEGER),
			new Column("name", DataType.VARCHAR), 
			new Column("vorname", DataType.VARCHAR), 
			new Column("titel", DataType.VARCHAR), 
			new Column("fakultaet", DataType.VARCHAR), 
		}
	);
professor.addRow(new Object[] { 
			Parameters.Professor.WAESCH_ID,
			"Wäsch",
			"Jürgen",
			"Prof. Dr.-Ing.",
			"Informatik",
		});
professor.addRow(new Object[] { 
			Parameters.Professor.HAASE_ID,
			"Haase",
			"Oliver",
			"Prof. Dr.",
			"Informatik",
		});
dataSet.addTable(professor);

DefaultTable lehrveranstaltung = new DefaultTable(
		"lehrveranstaltung", 
		new Column[] {
			new Column("id", DataType.INTEGER),
			new Column("professor_id", DataType.INTEGER),
			new Column("name", DataType.VARCHAR), 
			new Column("sws", DataType.INTEGER),
			new Column("ects", DataType.INTEGER),
		}
	);
lehrveranstaltung.addRow(new Object[] {
			Parameters.Lehrveranstaltung.VSYSTEME_ID,
			Parameters.Professor.HAASE_ID, 
			"Verteilte Systeme",
			4,
			5,
		});
lehrveranstaltung.addRow(new Object[] {
			Parameters.Lehrveranstaltung.DESIGN_PATTERNS_ID,
			Parameters.Professor.HAASE_ID,
			"Design Patterns",
			4,
			3,
		});
dataSet.addTable(lehrveranstaltung);
  \end{lstlisting}
	
	Diese Variante löst allerdings nicht alle Probleme. So müssen immer noch Meta-Informationen zu den Tabellen
	modelliert werden. Die Bewertung stellt sich wie folgt dar:
	
	\begin{itemize}

		\item \textbf{Zeilen}: Ähnlich wie für die Modellierung über XML-Dateien sind für eine übersichtliche Formatierung 
		  viele Zeilen notwendig und umfangreiche Datensets werden daher unübersichtlich. Für die Modellierung der Beispiel-Daten
		  werden 152 Zeilen benötigt, wovon ein beträchtlicher Teil nur für die Meta-Informationen zu den Tabellen
			beansprucht wird (siehe Zeilen 3-9 und 29-36).
		
		\item \textbf{Zeichen pro Zeile}: Mit maximal 74 Zeichen pro Zeile gibt es keine Probleme mit der Bildschirmdarstellung
		  für die Beispieldaten.
		
		\item \textbf{Typsicherheit}: Obwohl die Meta-Informationen zu den Tabellen sogar Typinformationen beinhalten, werden
		  Typ-Fehler erst zur Laufzeit beim Einspielen in die Datenbank erkannt.
		
		\item \textbf{Redundanz}: Redundante Werte können durch den Einsatz symbolischer Konstanten vermieden werden.

		\item \textbf{Benutzbarkeit (Verständlichkeit und Erlernbarkeit)}: 
		  Der Code ist zwar nicht unbedingt intuitiv, aber überschaubar und für einen Java-Programmierer auch leicht erlernbar.
			Die Verständlichkeit leidet unter denselben Problemen wie die \texttt{XmlDataSets}: Daten werden einfach in Form
			geordneter Listen übergeben, ohne dass direkt in der Umgebung ersichtlich ist, welcher Wert sich auf welche Spalte
			bezieht. Der Einsatz von Konstanten kann hier helfen. Davon kann auch die Modellierung von Beziehungen profitieren.
			
			Allerdings können solche Konstanten auch falsch verwendet werden: Eine doppelte Belegung ist genauso möglich wie
			das Zuweisen eines Fremdschlüssels auf den Primärschlüssel einer falschen Tabelle.
					
		\item \textbf{Modifizierbarkeit}:
		  Das Anpassen des DataSets an neue Datenbank-Schemen kann relativ umständlich werden, wenn Spalten hinzukommen oder
			wegfallen. Das Umbenennen von Spalten ist relativ leicht möglich. Einige Änderungen können durch
			IDE-Refactoring-Unterstützung einfach durchgeführt werden, z.B. das Ändern von Bezeichnern für Konstanten.

	\end{itemize}
  
	Insgesamt bietet die Nutzung dieser Java-DataSets wenig Vorteile gegenüber den XML-DataSets.

	\subsection{STU-DataSet}
	\label{sec:fragestellung:modellierung:sbtesting}
	
	Die Bibliothek \textit{STU} ermöglicht die Modellierung von DbUnit-DataSets mit Hilfe eines
	Datenbank-Modell-spezifischen API. Dieses API wird über einen Generator erzeugt (siehe auch
	\ref{sec:grundlagen:stu}). 
	
	\textit{STU} führt eine eigene DataSet-Klasse ein,
	über die die Daten modelliert werden. Diese DataSet-Klasse kann bei Bedarf von den aktuell in den
	\textit{STU}-Klassen gehaltenen Daten ein neues und unabhängiges DbUnit-DataSet erzeugen. Auf diese
	Weise können DataSets aus \textit{STU} einfacher und umfangreicher
	als DbUnit-DataSets modifiziert werden. So unterstützt \textit{STU} auch das Löschen von Zeilen
	aus einem DataSet.
	
	Eine Stärke von \textit{STU} ist es, dass verhältnismäßig einfach Varianten eines DbUnit-DataSets
	erzeugt werden können, z.B. ein DataSet mit dem Ausgangszustand und ein DataSet mit dem erwarteten
	Zustand am Ende des Tests.
	
	Die Java-DSL sorgt für statische Typsicherheit, so dass Java-IDEs fehlerhafte Typen bereits während der
	Entwicklung kenntlich machen. Verglichen mit den DbUnit-Xml-DataSets und dem Default-DataSet
	ist die Syntax etwas kompakter und ausdrucksstärker. Spaltennamen und Werte stehen beieinander und
	sind nicht über die Datei verteilt.

	\lstSetJava
	\begin{lstlisting}[caption=STU DataSet (1), label=listing:sbtestingdataset_old]
table_Professor
	.insertRow()
		.setId(Parameters.Professor.HAASE_ID)
		.setName("Haase")
		.setVorname("Oliver")
		.setTitel("Prof. Dr.")
		.setFakultaet("Informatik")
	.insertRow()
		.setId(Parameters.Professor.WAESCH_ID)
		.setName("Wäsch")
		.setVorname("Jürgen")
		.setTitel("Prof. Dr.-Ing.")
		.setFakultaet("Informatik");

table_Lehrveranstaltung
	.insertRow()
		.setId(Parameters.Lehrveranstaltung.VSYSTEME_ID)
		.setProfessorId(Parameters.Professor.HAASE_ID)
		.setName("Verteilte Systeme")
		.setSws(4)
		.setEcts(5)
	.insertRow()
		.setId(Parameters.Lehrveranstaltung.DESIGN_PATTERNS_ID)
		.setProfessorId(Parameters.Professor.HAASE_ID)
		.setName("Design Patterns")
		.setSws(4)
		.setEcts(3);
	\end{lstlisting}

  Für \textit{STU} ergibt sich folgende Bewertung:
	
	\begin{itemize}

		\item \textbf{Zeilen}: Auch in \textit{STU} dient es der Übersicht, für jeden Spaltenwert eine Zeile zu 
		  verwenden. Da die Meta-Informationen in den Builder-Klassen enthalten sind, kommt das Beispiel-DataSet
			auf 88 Zeilen.
		
		\item \textbf{Zeichen pro Zeile}: Mit maximal 67 Zeichen pro Zeile für das Beispiel-DataSet gibt es bei
		  der Bildschirm-Darstellung keine Probleme.
		
		\item \textbf{Typsicherheit}: Die Modellierung mit \textit{STU} ist typsicher, da statische Typ-Prüfungen
		  durchgeführt werden. Diese werden von gängigen IDEs bereits während der Eingabe des Codes durchgeführt.
		
		\item \textbf{Redundanz}: Da konkrete Werte durch benannte Konstanten ersetzt werden können, stellt
		  Redundanz für \textit{STU} kein Problem dar.

		\item \textbf{Benutzbarkeit (Verständlichkeit und Erlernbarkeit)}:
		  Der Code ist verständlich, aber nicht unbedingt übersichtlich. Die Nutzung gestaltet sich einfach,
			da die Builder-Klassen für jede Tabelle angepasste Methoden bieten und damit auch die Auto-Vervollständigung
			von IDEs zur Verfügung steht.
			
			In Bezug auf die Modellierung von Beziehungen gelten die Nachteile des Default-DataSets
			(\refsec{sec:fragestellung:modellierung:java}).
	
		\item \textbf{Modifizierbarkeit}: 
		  Durch Refactoring-Mechanismen von IDEs lassen sich viele Änderungen Werkzeug-unterstützt durchführen.
			Die statische Code-Analyse hilft beim Auffinden übrig gebliebener Daten nach dem Entfernen von Spalten
			aus dem Datenbank-Schema. Das Hinzufügen von Spalten erfordert mehr Handarbeit, ist aber nicht
			aufwändiger als in den bisher bewerteten Varianten.
	
	\end{itemize}

	Eine Erweiterung des Datenbank-Modells und des Generators kann die Modellierung von Beziehungen bereits etwas
	verbessern. Diese Erweiterung erlaubt es, anstelle eines Fremdschlüssels eine vorher eingefügte Zeile 
	anzugeben (\reflst{listing:sbtestingdataset}, Zeilen 20 und 27). Hier können referenzierte Primärschlüssel auch
	automatisch vergeben werden.

	\lstSetJava
	\begin{lstlisting}[caption=STU DataSet (2), label=listing:sbtestingdataset]
RowBuilder_Professor haase = 
	table_Professor
		.insertRow()
			.setName("Haase")
			.setVorname("Oliver")
			.setTitel("Prof. Dr.")
			.setFakultaet("Informatik");
RowBuilder_Professor waesch = 
	table_Professor
		.insertRow()
			.setName("Wäsch")
			.setVorname("Jürgen")
			.setTitel("Prof. Dr.-Ing.")
			.setFakultaet("Informatik");

RowBuilder_Lehrveranstaltung vsys = 
	table_Lehrveranstaltung
		.insertRow()
			.setName("Verteilte Systeme")
			.refProfessorId(haase)
			.setSws(4)
			.setEcts(5);
RowBuilder_Lehrveranstaltung design_patterns = 
	table_Lehrveranstaltung
		.insertRow()
			.setName("Design Patterns")
			.refProfessorId(haase)
			.setSws(4)
			.setEcts(3);
	\end{lstlisting}
	

	
