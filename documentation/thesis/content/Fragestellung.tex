\chapter{Anforderungsanalyse / Fragestellung}
\label{chap:anforderungen}

Einleiten: Zwei Fragestellungen, DSL und Generierung

\section{Allgemeine Anforderungen}
\label{sec:anforderungen:allgemeineanforderungen}

Da die Modellierung der Testdaten mit DbUnit-eigenen Mitteln einige Nachteile hat, hat SEITENBAU die
Bibliothek \textit{SB Testing DB} entwickelt. \textit{SB Testing DB} erweitert DbUnit um zusätzliche
Funktionen, löst aber nicht alle Schwierigkeiten bei der Modellierung von Test-Daten. Eine genauere
Betrachtung der Vor- und Nachteile verschiedener Modellierungsvarianten in Zusammenhang mit DbUnit
wird in Abschnitt \ref{sec:fragestellung:modellierung} dargelegt. Die Betrachtung der verschiedenen
Modellierungsvarianten soll als Grundlage für die Lösung dienen.

Die drei Hauptziele dieser Arbeit sind, die Modellierung von Beziehungen zu vereinfachen, die Modellierung
der Test-Daten übersichtlicher zu gestalten und die automatische Generierung von Test-Daten.
Für die Modellierung gelten diese allgemeinen Anforderungen:


\begin{itemize}
	\item \textbf{Integration in bestehende Werkzeugkette}: Die Lösung sollte sich nach Möglichkeit in die bestehende
	  Werkzeugkette von SEITENBAU integrieren lassen. Daraus folgt die Anforderung, dass sie sich in Java nutzen lassen soll. 
		
  \item \textbf{IDE-Integration}: Komfort für den Tester stellt eine der wichtigsten Anforderungen dar. Daten sollen
	  komfortabel modelliert werden können. Die Integration in Entwicklungsumgebungen wie Eclipse oder IntelliJ IDEA hat
		dabei einen maßgeblichen Anteil. 
	
	\item \textbf{Beziehungen}: Beziehungen sollen einfach modellieren werden können. 

	\item \textbf{Veränderbarkeit von DataSets}: Ähnlich wie bei \textit{SB Testing DB} sollen DataSets auch nachträglich
	  veränderbar sein. 
	
	\item \textbf{Komposition}: DataSets sollen sich aus anderen DataSets zusammensetzen lassen.
	
	\item \textbf{Gültigkeitsbereiche}: 
	  \todo{Gültigkeitsbereiche erklären}
	
	\item \textbf{Typ-Sicherheit}: Die Beschreibung der Daten sollte typsicher erfolgen. Idealerweise sollten falsche
	  Typen schon während des Compilierns erkannt werden..
		
	\item \textbf{Funktionen als Werte}: Es soll möglich sein, Hilfsfunktionen zur Berechnung von Werten zu verwenden,
	  z.b: zum Einlesen von Binary Large Objects (BLOBs) aus Dateien.
		
	\item \textbf{Zielgruppe}: Die Zielgruppe für die DSL sind Software-Entwickler und Tester. Der Code zur Modellierung
	  der Daten sollte auch für andere Projekt-Mitglieder lesbar und verständlich sein.

	\item \textbf{Ungültige Daten}: Es sollen sich auch aus Sicht der Datenbank oder des SUT ungültige Daten modellieren lassen.

\end{itemize}


Für die Generierung der Testdaten lassen sich die Anforderungen folgendermaßen zusammenfassen:
\begin{itemize}
	\item \textbf{Kompatiblität}: Die Generierung der Testdaten soll nicht nur bei Nutzung der neuen Modellierungssprache
	  verwendet werden können. Der Testdaten-Generator soll auch DataSets auf Basis der bisherigen SB-Testing-DB-Builder
		erstellen können.
\end{itemize}


\section{Fortlaufendes Beispiel}
\label{sec:fragestellung:beispiel}

% Beispiel einleiten
Ein einheitliches und fortlaufendes Beispiel soll der Arbeit als Grundlage dienen. Die Problemstellung besteht aus
einem Modell und einer Menge von Testdaten. Diese Testdaten dienen als Grundlage für die Diskussion der unterschiedlichen
Modellierungsvarianten.

	\subsection{Anforderungen an das Beispiel}
	\label{sec:fragestellung:beispiel:voraussetzungen}

	Der Schwerpunkt der Modellierung liegt bei der Darstellung von Beziehungstypen zwischen Entitätstypen. Dabei soll die
	Problemstellung einerseits nicht zu komplex sein, damit sie überschaubar bleibt. Andererseits soll sie komplex genug
	sein, um möglichst alle Beziehungsarten zwischen Entitäten abzudecken.
	Die Testdaten sollten gleichzeitig ein \textit{Standard Fixture} und ein \textit{Minimal Fixture} darstellen
	(\refsec{sec:grundlagen:konzepte:tests}).
	

	\subsection{Gewählte Problemstellung}
	\label{sec:fragestellung:beispiel:gewaehlte_problemstellung}
	Das gewählte Beispiel stellt eine starke Vereinfachung des Prüfungswesens an Hochschulen dar. Auf eine praxisnahe
	Umsetzung wird zugunsten der Komplexität verzichtet. Personenbezogene Begriffe werden in der maskulinen Form verwendet,
	ohne dabei Aussagen über das Geschlecht der repräsentierter Personen zu machen. Es beinhaltet die folgenden vier 
	Entitätstypen:

	\begin{itemize}
		\item \textbf{Professor}: Ein Professor leitet Lehrveranstaltungen.
		\item \textbf{Lehrveranstaltung}: Eine Lehrveranstaltung wird von einem Professor geleitet. Es kann zu jeder
			Lehrveranstaltung eine Prüfung geben.
		\item \textbf{Prüfung}: Eine Prüfung ist einer Lehrveranstaltung zugeordnet. Außerdem hat mindestens ein Professor
			Aufsicht.
		\item \textbf{Student}: Studenten können an Lehrveranstaltungen und an Prüfungen teilnehmen. Studenten haben außerdem 
			die Möglichkeit, Tutoren von Lehrveranstaltungen zu sein.
		\item \textbf{Raum}: Ein Professor kann einen Raum als Büro zugewiesen bekommen.
	\end{itemize}
	
	Die Beziehungen der Entitätstypen stellen sich wie folgt dar: 
	\begin{itemize}
		\item \textbf{leitet}: Eine Lehrveranstaltung muss von genau einem Professor geleitet werden, ein Professor kann beliebig viele
		  (also auch keine) Lehrveranstaltungen leiten.
		\item \textbf{geprüft}: Eine Prüfung ist genau einer Lehrveranstaltung zugeordnet. Eine Lehrveranstaltung kann mehrere Prüfungen 
		  haben (z.B. Nachschreibprüfung).
		\item \textbf{beaufsichtigt}: Eine Prüfung muss mindestens von einem Professor beaufsichtigt werden, ein Professor kann in 
		  beliebig vielen Prüfungen Aufsicht haben. 
		\item \textbf{besucht}: Jeder Student kann beliebig vielen Lehrveranstaltungen besuchen. Lehrveranstaltungen benötigen jedoch 
		  mindestens drei Besucher um stattzufinden und sind aus Kapazitätsgründen auf 100 Teilnehmer begrenzt.
		\item \textbf{ist Tutor}: Jeder Student kann bei beliebig vielen Lehrveranstaltungen Tutor sein und jede Lehrveranstaltung
			kann beliebig viele Tutoren haben. 
		\item \textbf{schreibt}: Jeder	Student kann an beliebig vielen Prüfungen teilnehmen und umgekehrt eine Prüfung von einer
		  beliebigen Anzahl von Studenten geschrieben werden.
		\item \textbf{hat Büro}: Ein Raum ist genau einem Professor zugewiesen. Ein Professor kann genau einen oder keinen Raum haben.
	\end{itemize}

	Abbildung \ref{img:example_er} zeigt das Beispiel grafisch in Form eines ER-Diagramms. Den verschiedenen Entitätstypen
	werden dabei Attribute zugeordnet. 
	
	\begin{figure}[H]
		\centering
		 \includegraphics[width=0.7\textwidth]{images/fragestellung/example_hochschule_er.pdf}
		\caption{ER-Diagramm des fortlaufenden Beispiels}\label{img:example_er}
	\end{figure}

	Das entsprechende Datenbank-Diagramm wird in Abbildung \ref{img:example_relational} dargestellt. 
	
	\begin{figure}[H]
		\centering
		 \includegraphics[width=0.95\textwidth]{images/fragestellung/example_hochschule_relational.pdf}
		\caption{Datenbank-Diagramm des fortlaufenden Beispiels}\label{img:example_relational}
	\end{figure}

	\todo{Legende}
	
	Das Attribut "`fakultaet"' in der Tabelle Professor soll als Aufzählungstyp (enumeration) realisiert werden.
	Mögliche Werte sind: Architektur, Bauingenieurwesen, Elektrotechnik, Informatik, Maschinenbau und Wirtschaftswesen.
	Das Foto des Professors wird als BLOB dargestellt.
	\nomenclature{BLOB}{Binary Large Object)}
	

	\subsection{Beispiel-Use-Cases}
	\label{sec:fragestellung:beispiel:usecases}

	Um den einen Kompromiss für die Komplexität der Testdaten zu finden, werden vier Fragestellungen definiert. Diese
	Fragen sollen dabei helfen, den Umfang der Testdaten bestimmen zu können. Die Fragen stellen sich wie folgt dar:

	\begin{enumerate}
		\item Welcher Professor unterrichtet die meisten Studenten?
		\item Welcher Student nimmt an den meisten Prüfungen teil?
		\item Welcher Student ist Tutor und nimmt gleichzeitig an der Prüfung teil?
		\item Welcher Professor macht die wenigste Aufsicht in Fremdveranstaltungen (Lehrveranstaltungen eines anderen
			Professors)?
	\end{enumerate}



\section{Modellierungsvarianten der Testdaten für DbUnit}
\label{sec:fragestellung:modellierung}
	
	In \textit{DbUnit} werden die Datenbankzustände durch DataSets repräsentiert. Für einen Test werden gewöhnlich zwei
	DataSets benötigt: das erste für den Anfangszustand, das zweite für den erwarteten Zustand. DataSets aus DbUnit bieten
	allerdings nicht die Möglichkeit, aus einem bestehenden DataSet ein zweites zu erzeugen, das die Änderungen an der
	Datenbank beinhaltet. 

	Im Folgenden werden verschiedene Modellierungsarten für DbUnit-DataSets diskutiert. Die Ergebnisse stellen die Grundlage
	für die konkretere Zielsetzung dar.
	

	\subsection{XML-DataSet}
	\label{sec:fragestellung:modellierung:xml}
	
	Eine Variante, ein DataSet für DbUnit zu modellieren, stellt XML dar. DbUnit bietet dazu zwei Varianten ein an.
	
	Die erste Variante stellt das \textit{XmlDataSet} dar. Diese Klasse liest eine XML-Datei nach einem von DbUnit
	vorgegebenen Dokumententyp ein. Das Listing \ref{listing:xmldataset} zeigt einen Ausschnitt einer solchen XML-Datei,
	in dem die beiden Tabellen \textit{Professor} und \textit{Lehrveranstaltung} definiert werden.
	
	\lstSetXML
	\begin{lstlisting}[caption=XML-DataSet, label=listing:xmldataset]
<!DOCTYPE dataset SYSTEM "dataset.dtd">
<dataset>
    <table name="PROFESSOR">
        <column>id</column>
        <column>name</column>
        <column>vorname</column>
        <column>titel</column>
        <column>fakultaet</column>
        <row>
            <value>1</value>
            <value>Wäsch</value>
            <value>Jürgen</value>
            <value>Prof. Dr.-Ing.</value>
            <value>Informatik</value>
        </row>
        <row>
            <value>2</value>
            <value>Haase</value>
            <value>Oliver</value>
            <value>Prof. Dr.</value>
            <value>Informatik</value>
        </row>
    </table>
    <table name="LEHRVERANSTALTUNG">
        <column>id</column>
        <column>professor_id</column>
        <column>name</column>
        <column>sws</column>
        <column>ects</column>
        <row>
            <value>1</value>
            <value>2</value>
            <value>Verteilte Systeme</value>
            <value>4</value>
            <value>5</value>
        </row>
        <row>
            <value>2</value>
            <value>2</value>
            <value>Design Patterns</value>
            <value>4</value>
            <value>3</value>
        </row>
    </table>
	...
</dataset>
	\end{lstlisting}
	
	Die positiven Eigenschaften bei der Modellierung mit XML sind unter anderem, dass für XML ein breites Angebot an
	Werkzeugen zur Verfügung steht. Diese können über den Dokumententyp prüfen, ob die Datei den Regeln entspricht.
	
	Der Aufbau dieser DbUnit-XML-Dateien erlaubt keine explizite Typ-Überprüfung durch XML-Editoren, da die
	Meta-Informationen zu den Spalten keine Angaben zu den Typen enthalten (Zeilen 4-8 und 25-29).
	
	Foreign-Key-Beziehungen in werden über hier über numerische Konstanten beschrieben. Die manuelle Pflege der Primär-
	und Fremdschlüssel ist unübersichtlich und damit fehleranfällig. In umfangreicheren DataSets sind 
	unkommentierte Beziehungen für Betrachter nur schwer nach zu vollziehen, da ein Schlüsselwert üblicherweise keinen
	unmittelbaren Rückschluss auf den referenzierten Datensatz erlaubt.
	
	Ein großer Nachteil bei der Nutzung von \texttt{XmlDataSet} ist, dass der erwartete Datenbankzustand selbst wieder den 
	kompletten Datenbankbestand umfassen muss. DbUnit erlaubt zwar mehrere DataSets zu einem zusammenzufassen, das Entfernen 
	von Datensätzen ist darüber aber nicht möglich. Mehrere XML-Dateien mit ähnlichen, überwiegend sogar gleichen Daten,
	sorgen für ein hohes Maß an Redundanz. Darüber hinaus sieht DbUnit keinen Mechanismus für die Komposition von XML-DataSets
	auf Modellierungsebene vor, d.h. es geht aus einer solchen XML-Datei nicht hervor, dass sie auf anderen DataSets
	aufbaut und diese erweitert.
	
  DbUnit-konforme XML-Dateien wachsen schnell in vertikaler Richtung und enthalten unter Umständen auch viel
	syntaktischen Overhead. Von den rund 30 gezeigten Zeilen enthalten nur zehn Zeilen wirkliche Daten bzw. drücken
	Beziehungen aus (Zeilen 21 und 26).
	
	% Modellieren Assoziativer Tabellen ansprechen?

  Die zweite Variante ist die Klasse ist \texttt{FlatXmlDataSet}. Hierbei gibt es keine
	von DbUnit vorgegebene DTD, da die Tags den Tabellen-Namen entsprechen\footnote{Es ist möglich, eine eigene DTD zu
	definieren.}. Eine solche XML-Datei kommt ohne explizite Meta-Informationen zu den Tabellen aus. Stattdessen stellen sie
	eine Art Sprachelement dar und werden für die Zuweisung der Werte verwendet. In diesem Punkt ist das \texttt{FlatXmlDataSet}
	übersichtlicher als das XmlDataSet (\reflst{listing:flatxmldataset}).
  
	\lstSetXML
	\begin{lstlisting}[caption=Flat-XML-DataSet, label=listing:flatxmldataset]
<?xml version='1.0' encoding='UTF-8'?>
<dataset>
    <PROFESSOR id="1" 
        name="Wäsch"
        vorname="Jürgen"
        titel="Prof. Dr.-Ing."
        fakultaet="Informatik" />
    <PROFESSOR id="2" 
        name="Haase"
        vorname="Oliver"
        titel="Prof. Dr."
        fakultaet="Informatik" />
    <LEHRVERANSTALTUNG id="1"
        professor_id="2"
        name="Verteilte Systeme"
        sws="4"
        ects="5" />
    <LEHRVERANSTALTUNG id="2"
        professor_id="2"
        name="Design Patterns"
        sws="4"
        ects="3" />
...
</dataset>
	\end{lstlisting}
	
	Wie auch beim \texttt{XmlDataSet} sollte der Übersicht wegen für jeden Wert eine Zeile verwendet werden. Durch die fehlende
	Hierarchie wirkt das \texttt{FlatXmlDataSet} etwas unübersichtlich.
	
  DbUnit bietet keine explizite Unterstützung für BLOBs in XML, um z.B. Daten aus einer anderen Datei einzulesen. Solche
	Funktionen müssen in DbUnit-DataSets grundsätzlich manuell implementiert werden.


	\subsection{Default-DataSet}
	\label{sec:fragestellung:modellierung:java}
	
	DbUnit erlaubt auch die programmatische Modellierung von DataSets. Dazu stellt es die Klasse \texttt{DefaultDataSet}
	bereit. Mit den Mitteln, die eine Programmiersprache wie Java bietet, lassen sich einige der Nachteile in Verbindung
  mit den XML-basierten DataSets direkt umgehen.
	
	So können Beziehungen mit Hilfe symbolischer Konstanten ausdrucksstärker modelliert werden. Auch wenn die Beziehungen
	immer noch etwas umständlich modelliert werden müssen, können symbolische Konstanten dabei helfen, Redundanz zu vermeiden
	und damit das Risiko für Fehler zu senken.

	\lstSetJava
	\begin{lstlisting}[caption=Default-DataSet, label=listing:javadataset]
DefaultTable professor = new DefaultTable(
		"professor",
		new Column[] { 
			new Column("id", DataType.INTEGER),
			new Column("name", DataType.VARCHAR), 
			new Column("vorname", DataType.VARCHAR), 
			new Column("titel", DataType.VARCHAR), 
			new Column("fakultaet", DataType.VARCHAR), 
		}
	);
professor.addRow(new Object[] { 
			Parameters.Professor.WAESCH_ID,
			"Wäsch",
			"Jürgen",
			"Prof. Dr.-Ing.",
			"Informatik",
		});
professor.addRow(new Object[] { 
			Parameters.Professor.HAASE_ID,
			"Haase",
			"Oliver",
			"Prof. Dr.",
			"Informatik",
		});
dataSet.addTable(professor);

DefaultTable lehrveranstaltung = new DefaultTable(
		"lehrveranstaltung", 
		new Column[] {
			new Column("id", DataType.INTEGER),
			new Column("professor_id", DataType.INTEGER),
			new Column("name", DataType.VARCHAR), 
			new Column("sws", DataType.INTEGER),
			new Column("ects", DataType.INTEGER),
		}
	);
lehrveranstaltung.addRow(new Object[] {
			Parameters.Lehrveranstaltung.VSYSTEME_ID,
			Parameters.Professor.HAASE_ID, 
			"Verteilte Systeme",
			4,
			5,
		});
lehrveranstaltung.addRow(new Object[] {
			Parameters.Lehrveranstaltung.DESIGN_PATTERNS_ID,
			Parameters.Professor.HAASE_ID,
			"Design Patterns",
			4,
			3,
		});
dataSet.addTable(lehrveranstaltung);
  \end{lstlisting}
	
	Diese Umsetzung löst allerdings nicht alle Probleme. So müssen immer noch Meta-Informationen über die Tabellen
	modelliert werden (Zeilen 3-9 und 29-36). Obwohl diese sogar Typinformationen beinhalten, werden Typ-Fehler erst
	zur Laufzeit erkannt \todo{Werden Typ-Fehler evtl erst beim Einspielen erkannt}. Der Einsatz von symbolischen 
	Konstanten erleichtert zwar die Pflege des DataSets, dennoch lassen sich Konstanten doppelt belegen oder auch
	Primärschlüssel einer falschen Datenbank als Fremdschlüssel angegeben werden.
	
	Ähnlich wie für die Modellierung über XML-Dateien sind für eine übersichtliche Formatierung  viele Zeilen notwendig
	und umfangreiche Datensets werden schnell unübersichtlich. Insgesamt bietet die Nutzung der Java-DataSets in dieser
  Art nur wenig Vorteile gegenüber den XML-DataSets.

	\subsection{SB-Testing-DB-DataSet}
	\label{sec:fragestellung:modellierung:sbtesting}
	
	Die Bibliothek \textit{SB Testing DB} der Firma SEITENBAU versucht Nachteile der XML- und
	Default-DataSets aufzufangen. In Abschnitt \ref{sec:grundlagen:sbtestingdb} wird diese Bibliothek beschrieben.
	Ein Generator erzeugt aus einem Datenbank-Modell für die Modellierung ein Java Fluent Builder API. 
	Im Gegensatz zu DbUnit-DataSets unterliegt dieses Modell wenig Einschränkungen in Bezug auf Modifikationen, 
	und erlaubt auch das Löschen von Datensätzen. Um die modellierten Daten in Verbindung
	mit DbUnit zu verwenden, kann aus dem Modell ein DbUnit-DataSet erzeugt werden. Der Vorteil dieses zusätzlichen 
	Modells ist, dass sich daraus verhältnismäßig einfach Varianten von DbUnit-DataSets erzeugen lassen, z.B. ein DataSet
	mit dem Ausgangszustand, 	und ein DataSet mit dem erwarteten Zustand am Ende des Tests. 
	
	Die Java-DSL sorgt für Typsicherheit zur Compilierzeit\footnote{Gängige Entwicklungsumgebungen wie Eclipse zeigen
	falsche Typen bereits während der Entwicklung an.}. Verglichen mit den DbUnit-Xml-DataSets und dem Default-DataSet
	ist die Syntax ist etwas kompakter und ausdrucksstärker. Spaltennamen und Werte stehen beieinander und nicht 
	über die Datei verteilt.

	\lstSetJava
	\begin{lstlisting}[caption=SB Testing DataSet (1), label=listing:sbtestingdataset_old]
table_Professor
	.insertRow()
		.setId(Parameters.Professor.HAASE_ID)
		.setName("Haase")
		.setVorname("Oliver")
		.setTitel("Prof. Dr.")
		.setFakultaet("Informatik")
	.insertRow()
		.setId(Parameters.Professor.WAESCH_ID)
		.setName("Wäsch")
		.setVorname("Jürgen")
		.setTitel("Prof. Dr.-Ing.")
		.setFakultaet("Informatik");

table_Lehrveranstaltung
	.insertRow()
		.setId(Parameters.Lehrveranstaltung.VSYSTEME_ID)
		.setProfessorId(Parameters.Professor.HAASE_ID)
		.setName("Verteilte Systeme")
		.setSws(4)
		.setEcts(5)
	.insertRow()
		.setId(Parameters.Lehrveranstaltung.DESIGN_PATTERNS_ID)
		.setProfessorId(Parameters.Professor.HAASE_ID)
		.setName("Design Patterns")
		.setSws(4)
		.setEcts(3);
	\end{lstlisting}

	Die Modellierung von Beziehungen stellt sich als ähnlich problematisch wie bei den bisherigen Java-DataSets dar
	(\refsec{sec:fragestellung:modellierung:java}). Nach wie vor wächst das DataSet vertikal in der Datei. 
	
	Zumindest das Problem mit den Beziehungen kann durch geringfügige Anpassungen am Generator und dem Datenbank-Modell
	entschärft werden. Ein um Beziehungen erweitertes Modell ermöglicht typsichere Referenzen auf andere Entitäten 
	(\reflst{listing:sbtestingdataset}, Zeilen 20 und 27). Bei dieser Variante kann unter Umständen darauf
	verzichtet werden, Primärschlüssel manuell zu vergeben.
	
	\lstSetJava
	\begin{lstlisting}[caption=SB Testing DataSet (2), label=listing:sbtestingdataset]
RowBuilder_Professor haase = 
	table_Professor
		.insertRow()
			.setName("Haase")
			.setVorname("Oliver")
			.setTitel("Prof. Dr.")
			.setFakultaet("Informatik");
RowBuilder_Professor waesch = 
	table_Professor
		.insertRow()
			.setName("Wäsch")
			.setVorname("Jürgen")
			.setTitel("Prof. Dr.-Ing.")
			.setFakultaet("Informatik");

RowBuilder_Lehrveranstaltung vsys = 
	table_Lehrveranstaltung
		.insertRow()
			.setName("Verteilte Systeme")
			.refProfessorId(haase)
			.setSws(4)
			.setEcts(5);
RowBuilder_Lehrveranstaltung design_patterns = 
	table_Lehrveranstaltung
		.insertRow()
			.setName("Design Patterns")
			.refProfessorId(haase)
			.setSws(4)
			.setEcts(3);
	\end{lstlisting}
