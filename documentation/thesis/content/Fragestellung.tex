\chapter{Anforderungsanalyse / Fragestellung}
\label{chap:anforderungen}

Einleiten: Zwei Fragestellungen, DSL und Generierung

\section{Allgemeine Anforderungen}
\label{sec:anforderungen:allgemeineanforderungen}

Die Hauptziele dieser Arbeit stellen sich wie folgt dar:
\begin{enumerate}
	\item Vereinfachen der Modellierung von Beziehungen
	\item Modellierung von Test-Daten übersichtlicher machen
	\item Automatisches Generieren von Test-Daten
\end{enumerate}


Für die Modellierung gelten diese allgemeinen Anforderungen:

\begin{itemize}
	\item \textbf{Integration in bestehende Werkzeugkette}: Die Lösung sollte sich nach Möglichkeit in die bestehende
	  Werkzeugkette von SEITENBAU integrieren lassen.  
		
  \item \textbf{IDE-Integration}: Bedienbarkeit für den Tester stellt eine der wichtigsten Anforderungen dar. Daten sollen
	  komfortabel modelliert werden können. Die Integration in Entwicklungsumgebungen wie Eclipse oder IntelliJ IDEA muss
		gegeben sein. 
	
	\item \textbf{Beziehungen}: Beziehungen sollen einfach modellieren werden können. 

	\item \textbf{Gültigkeitsbereiche}:
	  \todo{Gültigkeitsbereiche erklären}

	\item \textbf{Veränderbarkeit von DataSets}: DataSets sollen sich bei der Modellierung beliebig verändern lassen.
	
	\item \textbf{Komposition}: DataSets sollen sich aus anderen DataSets zusammensetzen lassen.
	
	
	\item \textbf{Typ-Sicherheit}: Die Beschreibung der Daten sollte typsicher erfolgen. Idealerweise sollten falsche
	  Typen schon während des Compilierns erkannt werden.
		
	\item \textbf{Funktionen als Werte}: Es soll möglich sein, Hilfsfunktionen zur Berechnung von Werten zu verwenden,
	  z.B. zum Einlesen von Binary Large Objects (BLOBs) aus Dateien.
		
	\item \textbf{Zielgruppe}: Die Zielgruppe für die DSL sind Software-Entwickler und Tester. Der Code zur Modellierung
	  der Daten sollte auch für andere Projekt-Mitglieder lesbar und verständlich sein.

	\item \textbf{Ungültige Daten}: Es sollen sich auch aus Sicht der Datenbank oder des SUT ungültige Daten modellieren lassen.

\end{itemize}


Für die Generierung der Testdaten lassen sich die Anforderungen folgendermaßen zusammenfassen:
\begin{itemize}
  
	\item \textbf{Fokus auf Beziehungen}: 
	
	\item \textbf{Datenmenge selbst bestimmen}:

	\item \textbf{Deterministische Generierung}: Auch wenn die Test-Daten aus Zufallsdaten bestehen, sollen sie deterministisch
	  generiert werden können. Das heißt, dass die Generierung des Modells mit den selben Einstellungen auch zum selben Ergebnis
		führt.
		
	\item \textbf{Kompatibilität}: Die Generierung der Testdaten soll in unterschiedliche Ausgabe-Formen erfolgen können,
	  z.B. in einer DSL, in XML oder auch in SQL-Statements.
	
\end{itemize}


\section{Modellierungskonzepte für Beziehungen}
\label{sec:fragestellung:modellierungskonzepte}
	
Je nach Beziehungsart gibt es unterschiedliche Ansätze, wie diese in einem ER-Diagramm umgesetzt werden können.
Dabei können neben den Entitäten auch die Beziehungen selbst Attribute haben.
Die folgenden drei grundsätzlichen Beziehungsarten werden dabei unterschieden:

	\subsection{1:1-Beziehungen}
	\label{sec:fragestellung:onetoone}
	
	Eine binäre Beziehung zwischen zwei Entitätstypen, wobei jede Entität innerhalb dieser Beziehung maximal einer
	anderen Entität zugeordnet sein kann. Eine solche Beziehung kann realisiert werden, indem eine Tabelle um einen
	Fremdschlüssel auf die andere erweitert wird. Dabei sollte der Fremdschlüssel und auch die beziehungsbeschreibenden
	Attribute immer der Tabelle hinzugefügt werden, deren Entitäten eine Beziehung voraussetzt.
	
	Wenn viele Beziehungsattribute vorhanden sind oder die Beziehung auf beiden Seiten optional ist,
	kann es auch sinnvoll sein, eine 1:1-Beziehung wie eine n:m-Beziehung zu modellieren.

	\subsection{1:n-Beziehungen}
	\label{sec:fragestellung:onetomany}

	Eine binäre Beziehung zwischen zwei Entitätstypen, wobei jede Entität des einen Typs in Beziehung mit mehreren
	Entitäten des anderen Typs stehen kann. Diese Entitäten können auch nur mit maximal einer Entität in Beziehung
	stehen. Es ist möglich festzulegen, wie viele Beziehungen eine Entität mindestens und höchstens haben darf.
	
	Die Tabelle der Entitäten, die maximal einer andere Entität zugeordnet sind, wird um einen Fremdschlüssel
	und um für jede Beziehung individueller Attribute erweitert. Die Beziehungsattribute, die für alle Beziehungen
	der beteiligten Entität gelten, werden ihrer Tabelle hinzugefügt.
	
	\subsection{n:m-Beziehungen}
	\label{sec:fragestellung:manytomany}
	
	Eine binäre Beziehung zwischen zwei Entitätstypen, wobei jede Entität des einen Typs mit mehreren Entitäten
	des anderen Typs in Beziehung stehen kann -- und umgekehrt. Es ist möglich, untere und obere Grenzwerte für
	die Anzahl der Beziehungen auf beiden Seiten festzulegen. Solche als assoziativ bezeichneten Beziehungen
	werden über eine Hilfstabelle modelliert, die entsprechend assoziative Tabelle genannt wird. Diese besteht
	aus den beiden Fremdschlüsseln auf die beteiligten Tabellen und den beziehungsbeschreibenden Attributen.
	
	Grundsätzlich können assoziative Tabellen für alle binären Beziehungen verwendet werden. Vor allem wenn 
	die Beziehung viele Attribute enthält, kann eine assoziative Tabelle für übersichtlichere Tabellenstrukturen
	sorgen.  

	\subsection{Andere Beziehungen}
	\label{sec:fragestellung:anderebeziehungen}
	
	In der aktuellen \textit{STU}-Implementierung müssen andere Beziehungen manuell umgesetzt werden. Dies gilt
	auch für zirkuläre und reflexive, sowie alle nicht-binären Beziehungen.



\section{Fortlaufendes Beispiel}
\label{sec:fragestellung:beispiel}

% Beispiel einleiten
Ein einheitliches fortlaufendes Beispiel soll der Arbeit als Grundlage dienen. Die Problemstellung besteht aus
einem Modell und einer Menge von Testdaten. Diese Testdaten dienen als Grundlage für die Diskussion der unterschiedlichen
Modellierungsvarianten.

	\subsection{Anforderungen an das Beispiel}
	\label{sec:fragestellung:beispiel:voraussetzungen}

	Der Schwerpunkt der Modellierung liegt bei der Darstellung von Beziehungstypen zwischen Entitätstypen. Dabei soll die
	Problemstellung einerseits nicht zu komplex sein, damit sie überschaubar bleibt. Andererseits soll sie komplex genug
	sein, um möglichst alle Beziehungsarten zwischen Entitäten abzudecken.
	Die Testdaten sollten gleichzeitig ein \textit{Standard Fixture} und ein \textit{Minimal Fixture} darstellen
	(\refsec{sec:grundlagen:konzepte:tests}).
	

	\subsection{Gewählte Problemstellung}
	\label{sec:fragestellung:beispiel:gewaehlte_problemstellung}
	Das gewählte Beispiel stellt eine starke Vereinfachung des Prüfungswesens an Hochschulen dar. Auf eine praxisnahe
	Umsetzung wird zugunsten der Komplexität verzichtet. Personenbezogene Begriffe werden in der maskulinen Form verwendet,
	ohne dabei Aussagen über das Geschlecht der repräsentierter Personen zu machen. Es beinhaltet die folgenden vier 
	Entitätstypen:

	\begin{itemize}
		\item \textbf{Professor}: Ein Professor leitet Lehrveranstaltungen.
		\item \textbf{Lehrveranstaltung}: Eine Lehrveranstaltung wird von einem Professor geleitet. Es kann zu jeder
			Lehrveranstaltung eine Prüfung geben.
		\item \textbf{Prüfung}: Eine Prüfung ist einer Lehrveranstaltung zugeordnet. Außerdem hat mindestens ein Professor
			Aufsicht.
		\item \textbf{Student}: Studenten können an Lehrveranstaltungen und an Prüfungen teilnehmen. Studenten haben außerdem 
			die Möglichkeit, Tutoren von Lehrveranstaltungen zu sein.
		\item \textbf{Raum}: Ein Professor kann einen Raum als Büro zugewiesen bekommen.
	\end{itemize}
	
	Die Beziehungen der Entitätstypen stellen sich wie folgt dar: 
	\begin{itemize}
		\item \textbf{leitet}: Eine Lehrveranstaltung muss von genau einem Professor geleitet werden, ein Professor kann beliebig viele
		  oder keine Lehrveranstaltungen leiten.
		\item \textbf{geprüft}: Eine Prüfung ist genau einer Lehrveranstaltung zugeordnet. Eine Lehrveranstaltung kann mehrere Prüfungen 
		  haben (z.B. Nachschreibprüfung).
		\item \textbf{beaufsichtigt}: Eine Prüfung muss mindestens von einem Professor beaufsichtigt werden, ein Professor kann in 
		  beliebig vielen Prüfungen Aufsicht haben. 
		\item \textbf{besucht}: Jeder Student kann beliebig vielen Lehrveranstaltungen besuchen. Lehrveranstaltungen benötigen jedoch 
		  mindestens drei Besucher um stattzufinden und sind aus Kapazitätsgründen auf 100 Teilnehmer begrenzt.
		\item \textbf{ist Tutor}: Jeder Student kann bei beliebig vielen Lehrveranstaltungen Tutor sein und jede Lehrveranstaltung
			kann beliebig viele Tutoren haben. 
		\item \textbf{schreibt}: Jeder	Student kann an beliebig vielen Prüfungen teilnehmen und umgekehrt eine Prüfung von einer
		  beliebigen Anzahl von Studenten geschrieben werden.
		\item \textbf{hat Büro}: Jeder Professor hat ein Büro. Ein Raum kann einem oder keinem Professor zugeordnet sein.
	\end{itemize}

	Abbildung \ref{img:example_er} zeigt das Beispiel grafisch in Form eines ER-Diagramms. Den verschiedenen Entitätstypen
	werden dabei Attribute zugeordnet. 
	
	\begin{figure}[H]
		\centering
		 \includegraphics[width=0.65\textwidth]{images/fragestellung/example_hochschule_er.pdf}
		\caption{ER-Diagramm des fortlaufenden Beispiels}\label{img:example_er}
	\end{figure}

	Das entsprechende relationale Datenbank-Diagramm wird in Abbildung \ref{img:example_relational} dargestellt. 
	
	\begin{figure}[H]
		\centering
		 \includegraphics[width=0.95\textwidth]{images/fragestellung/example_hochschule_relational.pdf}
		\caption{Relationales Datenbank-Diagramm des fortlaufenden Beispiels}\label{img:example_relational}
	\end{figure}

	Das Attribut "`fakultaet"' in der Tabelle Professor soll als Aufzählungstyp (enumeration) realisiert werden.
	Mögliche Werte sind: Architektur, Bauingenieurwesen, Elektrotechnik, Informatik, Maschinenbau und Wirtschaftswesen.
	Das Foto des Professors wird als BLOB dargestellt.
	\nomenclature{BLOB}{Binary Large Object)}
	

	\subsection{Beispiel-Use-Cases}
	\label{sec:fragestellung:beispiel:usecases}

	Um den einen Kompromiss für die Komplexität der Testdaten zu finden, werden vier Fragestellungen definiert. Diese
	Fragen sollen dabei helfen, den Umfang der Testdaten bestimmen zu können. Die Fragen stellen sich wie folgt dar:

	\begin{enumerate}
		\item Welcher Professor unterrichtet die meisten Studenten?
		\item Welcher Student nimmt an den meisten Prüfungen teil?
		\item Welcher Student ist Tutor und nimmt gleichzeitig an der Prüfung teil?
		\item Welcher Professor macht die wenigste Aufsicht in Fremdveranstaltungen (Lehrveranstaltungen eines anderen
			Professors)?
	\end{enumerate}


\todo{Überleitung}


\section{Modellierungsvarianten der Testdaten für DbUnit}
\label{sec:fragestellung:modellierung}
	
	In \textit{DbUnit} werden die Datenbankzustände durch DataSets repräsentiert. Für einen Test werden gewöhnlich zwei
	DataSets benötigt: das erste für den Anfangszustand, das zweite für den erwarteten Zustand. Allerdings bieten
	DbUnit-DataSets nur begrenzte Möglichkeiten, das DataSet mit dem erwarteten Zustand aus dem DataSet mit dem
	Anfangszustand zu erzeugen.

	Im Folgenden werden verschiedene Modellierungsarten für DbUnit-DataSets diskutiert. Diese soll anhand der im
	nächsten Abschnitt beschriebenen Kriterien erfolgen. Die Ergebnisse stellen die Grundlage
	für die konkretere Zielsetzung dar.

	\subsection{Kriterien für Bewertung}
	\label{sec:fragestellung:modellierung:sprachkriterien}

	\begin{itemize}

		\item \textbf{Zeilen}: Die Anzahl der Zeilen, die für ein DataSet benötigt werden. 
		
		\item \textbf{Zeichen pro Zeile}: Ist die Sprache für die Darstellung auf Bildschirmen geeignet?
		
		\item \textbf{Typsicherheit}:
		
		\item \textbf{Redundanz}: 

		\item \textbf{Benutzbarkeit (Verständlichkeit und Erlernbarkeit)}:
		
		\item \textbf{Modifizierbarkeit}:

	% http://de.wikipedia.org/wiki/ISO/IEC_9126	

	\end{itemize}


	\subsection{XML-DataSet}
	\label{sec:fragestellung:modellierung:xml}
	
	Eine Möglichkeit, ein DataSet für DbUnit zu modellieren, stellt XML dar. DbUnit selbst bietet zwei Varianten an, DataSets
	über XML zu modellieren.
	
	Die erste Variante stellt das \textit{XmlDataSet} dar. Diese Klasse liest eine XML-Datei nach einem von DbUnit
	vorgegebenen Dokumententyp ein. Das Listing \ref{listing:xmldataset} zeigt einen Ausschnitt einer solchen XML-Datei,
	in dem die beiden Tabellen \textit{Professor} und \textit{Lehrveranstaltung} definiert werden.
	
	\lstSetXML
	\begin{lstlisting}[caption=XML-DataSet, label=listing:xmldataset]
<!DOCTYPE dataset SYSTEM "dataset.dtd">
<dataset>
    <table name="PROFESSOR">
        <column>id</column>
        <column>name</column>
        <column>vorname</column>
        <column>titel</column>
        <column>fakultaet</column>
        <row>
            <value>1</value>
            <value>Wäsch</value>
            <value>Jürgen</value>
            <value>Prof. Dr.-Ing.</value>
            <value>Informatik</value>
        </row>
        <row>
            <value>2</value>
            <value>Haase</value>
            <value>Oliver</value>
            <value>Prof. Dr.</value>
            <value>Informatik</value>
        </row>
    </table>
    <table name="LEHRVERANSTALTUNG">
        <column>id</column>
        <column>professor_id</column>
        <column>name</column>
        <column>sws</column>
        <column>ects</column>
        <row>
            <value>1</value>
            <value>2</value>
            <value>Verteilte Systeme</value>
            <value>4</value>
            <value>5</value>
        </row>
        <row>
            <value>2</value>
            <value>2</value>
            <value>Design Patterns</value>
            <value>4</value>
            <value>3</value>
        </row>
    </table>
	...
</dataset>
	\end{lstlisting}
	
	Die positiven Eigenschaften bei der Modellierung mit XML sind unter anderem, dass für XML ein breites Angebot an
	Werkzeugen zur Verfügung steht. Diese können über den Dokumententyp prüfen, ob die Datei den Regeln entspricht.

  Zur Modellierung müssen Meta-Informationen zu den Daten hinterlegt werden. Diese beschränken sich allerdings auf
	die Bezeichnungen der Spalten (Zeilen 4-8 und 25-29). Da weitere Meta-Informationen fehlen, können fehlerhafte
	Datentypen oder Verstöße gegen Datenbank-Constraints erst zur Laufzeit beim Einspielen des DataSets erkannt werden.
	
	Beziehungen zwischen Datensätzen werden über numerische Konstanten realisiert. Die referenzierten Schlüssel 
	müssen in der entsprechenden Fremdschlüssel-Spalte verwendet werden. Die manuelle Pfege der Schlüssel kann
	unübersichtlich und damit fehleranfällig werdem. In umfangreicheren DataSets sind 
	unkommentierte Beziehungen für Betrachter nur schwer nach zu vollziehen, da ein Schlüsselwert üblicherweise keinen
	unmittelbaren Rückschluss auf den referenzierten Datensatz erlaubt.
	
	Ein großer Nachteil bei der Nutzung von \texttt{XmlDataSet} ist, dass der erwartete Datenbankzustand selbst wieder den 
	kompletten Datenbankbestand umfassen muss. DbUnit erlaubt zwar mehrere DataSets zu einem zusammenzufassen, das Entfernen 
	von Datensätzen ist darüber aber nicht möglich. Mehrere XML-Dateien mit ähnlichen, überwiegend sogar gleichen Daten,
	sorgen für ein hohes Maß an Redundanz. Darüber hinaus sieht DbUnit keinen Mechanismus für die Komposition von XML-DataSets
	auf Modellierungsebene vor, d.h. es geht aus einer solchen XML-Datei nicht hervor, dass sie auf anderen DataSets
	aufbaut und diese erweitert.
	
  DbUnit-konforme XML-Dateien wachsen schnell in vertikaler Richtung und enthalten unter Umständen auch viel
	syntaktischen Overhead. Von den rund 30 gezeigten Zeilen enthalten nur zehn Zeilen wirkliche Daten bzw. drücken
	Beziehungen aus (Zeilen 21 und 26).
	
	% Modellieren Assoziativer Tabellen ansprechen?

  Das \texttt{FlatXmlDataSet} stellt die zweite Variante dar. Hierbei gibt es keine
	von DbUnit vorgegebene DTD, da die Tags den Tabellen-Namen entsprechen\footnote{Es ist möglich, eine eigene DTD zu
	definieren.}. Eine solche XML-Datei kommt ohne explizite Meta-Informationen zu den Tabellen aus. Stattdessen stellen sie
	eine Art Sprachelement dar und werden für die Zuweisung der Werte verwendet. In Bezug auf die Meta-Informationen
	ist das \texttt{FlatXmlDataSet} übersichtlicher als das XmlDataSet (\reflst{listing:flatxmldataset}).
  
	\lstSetXML
	\begin{lstlisting}[caption=Flat-XML-DataSet, label=listing:flatxmldataset]
<?xml version='1.0' encoding='UTF-8'?>
<dataset>
    <PROFESSOR id="1" 
        name="Wäsch"
        vorname="Jürgen"
        titel="Prof. Dr.-Ing."
        fakultaet="Informatik" />
    <PROFESSOR id="2" 
        name="Haase"
        vorname="Oliver"
        titel="Prof. Dr."
        fakultaet="Informatik" />
    <LEHRVERANSTALTUNG id="1"
        professor_id="2"
        name="Verteilte Systeme"
        sws="4"
        ects="5" />
    <LEHRVERANSTALTUNG id="2"
        professor_id="2"
        name="Design Patterns"
        sws="4"
        ects="3" />
...
</dataset>
	\end{lstlisting}
	
	Wie auch beim \texttt{XmlDataSet} sollte der Übersicht wegen für jeden Wert eine Zeile verwendet werden. Durch die fehlende
	Hierarchie wirkt das \texttt{FlatXmlDataSet} etwas unübersichtlich.
	
  DbUnit unterstützt BLOBs in XML in Form Base64-codierter Daten. Bei größeren Datenmengen leidet die Übersicht unter dem
	Einbetten von BLOBs, nicht nur wegen der dem zusätzlichen Platzbedarf aufgrund der Codierung. Spezielle Mechanismen,
	BLOBs aus anderen Dateien einzulesen, bringt DbUnit nicht mit. Solche Funktionen müssen manuell implementiert werden.


	\subsection{Default-DataSet}
	\label{sec:fragestellung:modellierung:java}
	
	DbUnit erlaubt auch die programmatische Modellierung von DataSets. Dazu stellt es die Klasse \texttt{DefaultDataSet}
	bereit. Mit den Mitteln, die eine Programmiersprache wie Java bietet, lassen sich einige der Nachteile in Verbindung
  mit den XML-basierten DataSets direkt umgehen.
	
	So können Beziehungen mit Hilfe symbolischer Konstanten ausdrucksstärker modelliert werden. Auch wenn die Beziehungen
	immer noch etwas umständlich modelliert werden müssen, können symbolische Konstanten dabei helfen, Redundanz zu vermeiden
	und damit das Risiko für Fehler zu senken.

	\lstSetJava
	\begin{lstlisting}[caption=Default-DataSet, label=listing:javadataset]
DefaultTable professor = new DefaultTable(
		"professor",
		new Column[] { 
			new Column("id", DataType.INTEGER),
			new Column("name", DataType.VARCHAR), 
			new Column("vorname", DataType.VARCHAR), 
			new Column("titel", DataType.VARCHAR), 
			new Column("fakultaet", DataType.VARCHAR), 
		}
	);
professor.addRow(new Object[] { 
			Parameters.Professor.WAESCH_ID,
			"Wäsch",
			"Jürgen",
			"Prof. Dr.-Ing.",
			"Informatik",
		});
professor.addRow(new Object[] { 
			Parameters.Professor.HAASE_ID,
			"Haase",
			"Oliver",
			"Prof. Dr.",
			"Informatik",
		});
dataSet.addTable(professor);

DefaultTable lehrveranstaltung = new DefaultTable(
		"lehrveranstaltung", 
		new Column[] {
			new Column("id", DataType.INTEGER),
			new Column("professor_id", DataType.INTEGER),
			new Column("name", DataType.VARCHAR), 
			new Column("sws", DataType.INTEGER),
			new Column("ects", DataType.INTEGER),
		}
	);
lehrveranstaltung.addRow(new Object[] {
			Parameters.Lehrveranstaltung.VSYSTEME_ID,
			Parameters.Professor.HAASE_ID, 
			"Verteilte Systeme",
			4,
			5,
		});
lehrveranstaltung.addRow(new Object[] {
			Parameters.Lehrveranstaltung.DESIGN_PATTERNS_ID,
			Parameters.Professor.HAASE_ID,
			"Design Patterns",
			4,
			3,
		});
dataSet.addTable(lehrveranstaltung);
  \end{lstlisting}
	
	Diese Variante löst allerdings nicht alle Probleme: So müssen immer noch Meta-Informationen zu den Tabellen
	modelliert werden (Zeilen 3-9 und 29-36). Obwohl diese sogar Typinformationen beinhalten, werden Typ-Fehler erst
	zur Laufzeit beim Einspielen in die Datenbank erkannt. Der Einsatz von symbolischen 
	Konstanten erleichtert zwar die Pflege des DataSets, dennoch lassen sich Konstanten doppelt belegen oder auch
	Primärschlüssel einer falschen Datenbank als Fremdschlüssel angegeben werden.
	
	Ähnlich wie für die Modellierung über XML-Dateien sind für eine übersichtliche Formatierung  viele Zeilen notwendig
	und umfangreiche Datensets werden daher unübersichtlich. Insgesamt bietet die Nutzung dieser Java-DataSets 
	wenig Vorteile gegenüber den XML-DataSets.

	\subsection{STU-DataSet}
	\label{sec:fragestellung:modellierung:sbtesting}
	
	Die Bibliothek \textit{STU} ermöglicht die Modellierung von DbUnit-DataSets mit Hilfe eines
	Datenbank-Modell-spezifischen API. Dieses API wird über einen Generator erzeugt (siehe auch
	\ref{sec:grundlagen:stu}). 
	
	\textit{STU} führt eine eigene DataSet-Klasse ein,
	über die die Daten modelliert werden. Diese DataSet-Klasse kann bei Bedarf von den aktuellen Daten ein
	DbUnit-DataSet erzeugen. Auf diese Weise können DataSets aus \textit{STU} einfacher und umfangreicher
	als DbUnit-DataSets modifiziert werden, wie z.B. das Löschen von Zeilen.
	
	Auf diese Weise können mit \textit{STU} verhältnismäßig einfach Varianten eines DbUnit-DataSets
	erzeugt werden, z.B. ein DataSet mit dem Ausgangszustand und ein DataSet mit dem erwarten Zustand am Ende des Tests.
	
	Die Java-DSL sorgt für statische Typsicherheit, so dass Java-IDEs fehlerhafte Typen bereits während der
	Entwicklung kenntlich machen. Verglichen mit den DbUnit-Xml-DataSets und dem Default-DataSet
	ist die Syntax ist etwas kompakter und ausdrucksstärker. Spaltennamen und Werte stehen beieinander und nicht 
	über die Datei verteilt.

	\lstSetJava
	\begin{lstlisting}[caption=STU DataSet (1), label=listing:sbtestingdataset_old]
table_Professor
	.insertRow()
		.setId(Parameters.Professor.HAASE_ID)
		.setName("Haase")
		.setVorname("Oliver")
		.setTitel("Prof. Dr.")
		.setFakultaet("Informatik")
	.insertRow()
		.setId(Parameters.Professor.WAESCH_ID)
		.setName("Wäsch")
		.setVorname("Jürgen")
		.setTitel("Prof. Dr.-Ing.")
		.setFakultaet("Informatik");

table_Lehrveranstaltung
	.insertRow()
		.setId(Parameters.Lehrveranstaltung.VSYSTEME_ID)
		.setProfessorId(Parameters.Professor.HAASE_ID)
		.setName("Verteilte Systeme")
		.setSws(4)
		.setEcts(5)
	.insertRow()
		.setId(Parameters.Lehrveranstaltung.DESIGN_PATTERNS_ID)
		.setProfessorId(Parameters.Professor.HAASE_ID)
		.setName("Design Patterns")
		.setSws(4)
		.setEcts(3);
	\end{lstlisting}

	Die Modellierung von Beziehungen stellt sich als ähnlich problematisch wie bei den bisherigen Java-DataSets dar
	(\refsec{sec:fragestellung:modellierung:java}). Nach wie vor wächst das DataSet vertikal in der Datei. 
	
	Eine Erweiterung des Datenbank-Modells und des Generators kann die Modellierung von Beziehungen bereits etwas
	verbessern. Diese Erweiterung erlaubt es, anstelle eines Fremdschlüssels eine vorher eingefügte Zeile 
	anzugeben (\reflst{listing:sbtestingdataset}, Zeilen 20 und 27). Hier können referenzierte Primärschlüssel auch
	automatisch vergeben werden.
	
	\lstSetJava
	\begin{lstlisting}[caption=STU DataSet (2), label=listing:sbtestingdataset]
RowBuilder_Professor haase = 
	table_Professor
		.insertRow()
			.setName("Haase")
			.setVorname("Oliver")
			.setTitel("Prof. Dr.")
			.setFakultaet("Informatik");
RowBuilder_Professor waesch = 
	table_Professor
		.insertRow()
			.setName("Wäsch")
			.setVorname("Jürgen")
			.setTitel("Prof. Dr.-Ing.")
			.setFakultaet("Informatik");

RowBuilder_Lehrveranstaltung vsys = 
	table_Lehrveranstaltung
		.insertRow()
			.setName("Verteilte Systeme")
			.refProfessorId(haase)
			.setSws(4)
			.setEcts(5);
RowBuilder_Lehrveranstaltung design_patterns = 
	table_Lehrveranstaltung
		.insertRow()
			.setName("Design Patterns")
			.refProfessorId(haase)
			.setSws(4)
			.setEcts(3);
	\end{lstlisting}
