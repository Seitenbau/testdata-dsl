\chapter{Grundlagen}
\label{chap:grundlagen}

\section{Fortlaufendes Beispiel}
\label{sec:grundlagen:beispiel}

% Beispiel einleiten
Eine einheitliche und fortlaufende Problemstellung soll der Arbeit als Grundlage dienen. Die Problemstellung besteht aus
einem Modell und einem Satz von Testdaten. Alle im weiteren Verlauf diskutierten Modellierungsvarianten werden diese
Problemstellung umsetzen und die Testdaten modellieren.  

	\subsection{Voraussetzungen}
	\label{sec:grundlagen:beispiel:voraussetzungen}

	Der Schwerpunkt der Modellierung liegt bei der Darstellung von Beziehungen zwischen Entitäten. Dabei soll die
	Problemstellung einerseits nicht zu komplex sein, damit sie überschaubar bleibt. Andererseits soll sie komplex genug
	sein, um möglichst alle Beziehungsarten zwischen Entitäten abzudecken.

	Die Testdaten sollten gleichzeitig ein \textit{Standard Fixture} und ein \textit{Minimal Fixture} darstellen.
	\textit{Standard Fixture} bedeutet, dass die selben Testdaten für alle Tests verwendet werden 
	(\cite[317]{XUNIT_TEST_PATTERNS}). Nur in Ausnahmefällen sollten Tests modifizierte oder eigene Testdaten verwenden.
	Dadurch muss sich der Tester für verschiedene Tests nicht in unterschiedliche Daten hineinversetzen.
	Ein \textit{Minimal Fixture} kann die Laufzeit der Tests verbessern, in dem das Fixture nur Daten enthält, die für den
	Test notwendig sind (\cite[302]{XUNIT_TEST_PATTERNS}). Da auf unnötige Testdaten verzichtet wird, kann der Tester die 
	Daten leichter überblicken.
	

	\subsection{Gewählte Problemstellung}
	\label{sec:grundlagen:beispiel:gewaehlte_problemstellung}
	Das gewählte Beispiel stellt eine starke Vereinfachung des Prüfungswesens an Hochschulen dar. Auf eine praxisnahe
	Umsetzung wird zugunsten der Komplexität verzichtet. Es beinhaltet die folgenden vier Entitäten:

	\begin{itemize}
		\item \textbf{Professor}: Ein Professor leitet Lehrveranstaltungen.
		\item \textbf{Lehrveranstaltung}: Eine Lehrveranstaltung wird von einem Professor geleitet. Es kann zu jeder
			Lehrveranstaltung eine Prüfung geben.
		\item \textbf{Prüfung}: Eine Prüfung ist einer Lehrveranstaltung zugeordnet. Außerdem hat mindestens ein Professor
			Aufsicht.
		\item \textbf{Student}: Studenten können an Lehrveranstaltungen und an Prüfungen teilnehmen. Studenten haben außerdem 
			die Möglichkeit, Tutoren von Lehrveranstaltungen zu sein.
	\end{itemize}

	Die Beziehungen der Entitäten stellen sich wie folgt dar: Eine Lehrveranstaltung muss von genau einem Professor
	geleitet werden, ein Professor kann beliebig viele (also auch keine) Lehrveranstaltungen leiten. Eine Prüfung ist genau
	einer Lehrveranstaltung zugeordnet. Eine Lehrveranstaltung kann mehrere Prüfungen haben (z.B. Nachschreibprüfung).
	Eine Prüfung muss mindestens von einem Professor beaufsichtigt werden, ein Professor kann in beliebig vielen Prüfungen
	Aufsicht haben. Jeder Student kann beliebig vielen Lehrveranstaltungen besuchen und Lehrveranstaltungen von beliebig
	vielen Studenten besucht werden. Die gleiche Beziehung gilt für Tutoren: Jeder Student kann bei beliebig vielen
	Lehrveranstaltungen Tutor sein und jede Lehrveranstaltung kann beliebig viele Tutoren haben. Schließlich kann jeder
	Student auch an beliebig vielen Prüfungen teilnehmen und umgekehrt eine Prüfung von einer beliebigen Anzahl von
	Studenten geschrieben werden.

	Abbildung \ref{img:example_er} zeigt die Problemstellung grafisch in Form eines ER-Diagramms. Sie veranschaulicht,
	dass es keine 1:1 Beziehung gibt. Eine 1:1-Beziehung kann jedoch als Spezialfall einer 1:n-Beziehung angesehen werden.

	\begin{figure}[H]
		\centering
		 \includegraphics[width=0.8\textwidth]{images/grundlagen/example_hochschule_er.pdf}
		\caption{ER-Diagramm des fortlaufenden Beispiels}\label{img:example_er}
	\end{figure}

	Das entsprechende relationale Modell sieht folgendermaßen aus:
	\begin{figure}[H]
		\centering
		 \includegraphics[width=0.95\textwidth]{images/grundlagen/example_hochschule_relational.pdf}
		\caption{Relationales Modell des fortlaufenden Beispiels}\label{img:example_relational}
	\end{figure}

	\subsection{Wahl der Testdaten}
	\label{sec:grundlagen:beispiel:testdaten}

	Um den einen Kompromiss für die Komplexität der Testdaten zu finden, werden vier Fragestellungen definiert. Diese
	Fragen sollen dabei helfen, den Umfang der Testdaten bestimmen zu können. Die Fragen stellen sich wie folgt dar:

	\begin{enumerate}
		\item Welcher Professor unterrichtet die meisten Studenten?
		\item Welcher Student nimmt an den meisten Prüfungen teil?
		\item Welcher Student ist Tutor und nimmt gleichzeitig an der Prüfung teil?
		\item Welcher Professor macht die wenigste Aufsicht in Fremdveranstaltungen (Lehrveranstaltungen eines anderen
			Professors)?
	\end{enumerate}

	\todo{Daten beschreiben}
	
	
	

\section{Modellierung der Testdaten in DbUnit}
\label{sec:grundlagen:modellierung}

	Eine übliche Vorgehensweise, Systeme in Verbindung mit Datenbanken zu testen, stellt \textit{Back Door Manipulation} dar.
	Dabei wird die Datenbank über direkten Zugriff, vorbei am zu testenden System, in den Anfangszustand gebracht.
	Anschließend können die zu testenden Operationen am System durchgeführt werden. Um zu überprüfen, ob sich das System richtig
	verhalten hat, wird der Zustand der Datenbank mit dem erwarteten Zustand verglichen - ebenfalls am zu testenden System vorbei.
	\cite[327ff]{XUNIT_TEST_PATTERNS}
	
	\todo{Grafik Back Door Manipulation}
	
	Es gibt mehrere Vorteile, die Datenbank nicht über das zu testende System in den Anfangszustand zu bringen. Einerseits können
	semantische Fehler im zu testenden System unter Umständen nur so gefunden werden. Andererseits kann der Zustand mitunter
	schneller in die Datenbank geschrieben werden, wenn nicht der Weg über das zu testende System gemacht wird. Außerdem bietet es
	in Bezug auf die Zustände eine höhere Flexibilität: Die Datenbank kann auch in Zustände	gebracht werden, die über das System
	nicht erreicht werden können. Dafür leidet die Flexibilität an einer anderen Stelle: Die Tests sind abhängig von der Plattform.
	
	In \textit{DbUnit} werden die Datenbankzustände durch Datasets repräsentiert. Für einen Test werden gewöhnlich zwei Datasets
	benötigt: das erste für den Anfangszustand, das zweite für den erwarteten Zustand. Datasets aus \textit{DbUnit} bieten allerdings
	nicht die Möglichkeit, aus einem bestehenden Dataset ein zweites zu erzeugen, das die Änderungen an der Datenbank beinhaltet. 
	
	Im Folgenden werden verschiedene Modellierungsarten für \textit{DbUnit}-Datasets diskutiert. Die Erkenntnisse sollen in die 
	Anforderungen an die DSL einfließen.
	

	\subsection{XML-Dataset}
	\label{sec:grundlagen:modellierung:xml}

	
	Eine Variante, ein Dataset für \textit{DbUnit} zu modellieren, stellt XML dar. \textit{DbUnit} biete dazu die Klasse
	\textit{XmlDataSet}, das eine XML-Datei nach einem vorgegebenen Dokumententyp einlesen kann. Das Listing \ref{listing:xmldataset}
	zeigt einen Ausschnitt einer solchen XML-Datei, in dem die beiden Tabellen \textit{professor} und \textit{lehrveranstaltung}
	definiert wedren.
	
	\lstSetXML
	\begin{lstlisting}[caption=XML Dataset, label=listing:xmldataset]
<!DOCTYPE dataset SYSTEM "dataset.dtd">
<dataset>
    <table name="PROFESSOR">
        <column>id</column>
        <column>name</column>
        <column>vorname</column>
        <column>titel</column>
        <column>fakultaet</column>
        <row>
            <value>1</value>
            <value>Wäsch</value>
            <value>Jürgen</value>
            <value>Prof. Dr.-Ing.</value>
            <value>Informatik</value>
        </row>
        <row>
            <value>2</value>
            <value>Haase</value>
            <value>Oliver</value>
            <value>Prof. Dr.</value>
            <value>Informatik</value>
        </row>
    </table>
    <table name="LEHRVERANSTALTUNG">
        <column>id</column>
        <column>professor_id</column>
        <column>name</column>
        <column>sws</column>
        <column>ects</column>
        <row>
            <value>1</value>
            <value>2</value>
            <value>Verteilte Systeme</value>
            <value>4</value>
            <value>5</value>
        </row>
        <row>
            <value>2</value>
            <value>2</value>
            <value>Design Patterns</value>
            <value>4</value>
            <value>3</value>
        </row>
    </table>
	...
</dataset>
	\end{lstlisting}
	
	Die positiven Eigenschaften bei der Modellierung in XML sind unter anderem, dass für XML ein breites Angebot an Werkzeugen
	zur Verfügung steht. Diese können über den Dokumententyp prüfen, ob die Datei den Regeln entspricht.
	
	Leider können die Werkzeuge kaum erkennen, ob in den einzelnen Zellen die richtigen Typen verwendet werden. Die in der 
	XML-Datei enthaltenen Meta-Informationen (Beschreibung der Spalten, Zeilen 4-8 und 25-29) reichen dafür nicht
	aus. Die Meta-Informationen sind redundant und erschweren die Pflege.
	
	Das Modellieren von Referenzen findet auf einer niedrigen Abstraktionsebene statt und ist damit unübersichtlich und
	fehleranfällig. Primär- und Fremdschlüssel müssen von Hand angegeben werden, die Werte tauchen redundant auf und sind 
	ohne Kommentare in umfangreicheren Datasets für Betrachter nur schwer nachzuvollziehen. Die Beziehungen werden auf 
	einer sehr niedrigen Abstraktionsebene ausgedrückt und 
	
	Ein großer Nachteil von XML-Datasets ist, dass der erwartete Datenbankzustand selbst wieder den kompletten
	Datenbankbestand umfassen muss. Eine inkrementelle bzw. differentielle Definition der erwarteten Änderungen ist über
	XML-Datasets nicht möglich. Mehrere XML-Dateien mit ähnlichen, überwiegend sogar gleichen Daten, sorgen für ein
	hohes Maß an Redundanz.
	
	Datasets in XML wachsen schnell in vertikaler Richtung und enthalten unter Umständen auch viel syntaktischen Overhead.
	Von den rund 30 gezeigten Zeilen enthalten nur zehn Zeilen wirkliche Daten bzw. drücken Beziehungen aus (Zeilen 21 
	und 26).
	
	% Modellieren Assoziativer Tabellen ansprechen?


	\subsection{Java-Dataset}
	\label{sec:grundlagen:modellierung:java}

	
	Um einige der Probleme zu vermeiden, die in Verbindung mit XML-Datasets auftreten, können Java-Datasets verwendet
	werden. Diese lassen sich dynamisch erstellen. Java-Datasets lösen einen Teil der Redundanz-Probleme, da symbolische
	Konstanten anstelle von numerischen verwendet werden können. Das Erzeugen des Datasets, das den erwarteten 
	Datenbankzustand repräsentiert, bleibt umständlich, ist aber auf Java-Ebene mit weniger Redundanz lösbar.

	\lstSetJava
	\begin{lstlisting}[caption=Java Dataset, label=listing:javadataset]
DefaultTable professor = new DefaultTable(
		"professor",
		new Column[] { 
			new Column("id", DataType.INTEGER),
			new Column("name", DataType.VARCHAR), 
			new Column("vorname", DataType.VARCHAR), 
			new Column("titel", DataType.VARCHAR), 
			new Column("fakultaet", DataType.VARCHAR), 
		}
	);
professor.addRow(new Object[] { 
			Parameters.Professor.WAESCH_ID,
			"Wäsch",
			"Jürgen",
			"Prof. Dr.-Ing.",
			"Informatik",
		});
professor.addRow(new Object[] { 
			Parameters.Professor.HAASE_ID,
			"Haase",
			"Oliver",
			"Prof. Dr.",
			"Informatik",
		});
dataSet.addTable(professor);

DefaultTable lehrveranstaltung = new DefaultTable(
		"lehrveranstaltung", 
		new Column[] {
			new Column("id", DataType.INTEGER),
			new Column("professor_id", DataType.INTEGER),
			new Column("name", DataType.VARCHAR), 
			new Column("sws", DataType.INTEGER),
			new Column("ects", DataType.INTEGER),
		}
	);
lehrveranstaltung.addRow(new Object[] {
			Parameters.Lehrveranstaltung.VSYSTEME_ID,
			Parameters.Professor.HAASE_ID, 
			"Verteilte Systeme",
			4,
			5,
		});
lehrveranstaltung.addRow(new Object[] {
			Parameters.Lehrveranstaltung.DESIGN_PATTERNS_ID,
			Parameters.Professor.HAASE_ID,
			"Concurrency and Design Patterns",
			4,
			3,
		});
dataSet.addTable(lehrveranstaltung);
  \end{lstlisting}
	
	Diese Umsetzung löst allerdings nicht alle Probleme. So müssen immer noch Meta-Informationen über die Tabellen
	modelliert werden. Obwohl diese sogar Typinformationen beinhalten, werden Typ-Fehler erst zur Laufzeit erkannt.
	Der Einsatz von symbolischen Konstanten verringert die Redundanz zwar und erleichtert damit die Pflege des Datasets,
	dennoch lassen sich Konstanten doppelt belegen und es können auch Primärschlüssel einer falschen Datenbank als
	Fremdschlüssel angegeben werden.
	
	Ähnlich wie für die Modellierung über XML-Dateien sind für eine übersichtliche Formatierung  viele Zeilen notwendig
	und umfangreiche Datensets werden schnell unübersichtlich. Insgesamt bietet die Nutzung der Java-Datasets in dieser Art
	nur wenig Vorteile gegenüber den XML-Datasets.

	\subsection{SB Testing DSL}
	\label{sec:grundlagen:modellierung:sbtesting}

	
	\todo{SB Testing DSL}
	Generator erzeugt DSL auf Basis von Meta-Daten (M2). 

	\begin{figure}[H]
		\centering
		 \includegraphics[width=0.95\textwidth]{images/grundlagen/example_hochschule_model.png}
		\caption{Modell-Beschreibung}\label{img:example_hochschule_model}
	\end{figure}

	\lstSetJava
	\begin{lstlisting}[caption=SB Testing Dataset (1), label=listing:sbtestingdataset_old]
table_Professor
	.insertRow()
		.setId(Parameters.Professor.HAASE_ID)
		.setName("Haase")
		.setVorname("Oliver")
		.setTitel("Prof. Dr.")
		.setFakultaet("Informatik")
	.insertRow()
		.setId(Parameters.Professor.WAESCH_ID)
		.setName("Wäsch")
		.setVorname("Jürgen")
		.setTitel("Prof. Dr.-Ing.")
		.setFakultaet("Informatik");

table_Lehrveranstaltung
	.insertRow()
		.setId(Parameters.Lehrveranstaltung.VSYSTEME_ID)
		.setProfessorId(Parameters.Professor.HAASE_ID)
		.setName("Verteilte Systeme")
		.setSws(4)
		.setEcts(5)
	.insertRow()
		.setId(Parameters.Lehrveranstaltung.DESIGN_PATTERNS_ID)
		.setProfessorId(Parameters.Professor.HAASE_ID)
		.setName("Design Patterns")
		.setSws(4)
		.setEcts(3);
	\end{lstlisting}

	Die SB Testing DSL versucht die Nachteile der Java-Datasets zu umgehen. Die Syntax ist kompakter und dennoch
	ausdrucksstärker als die beiden vorherigen Varianten. Außerdem können falsche Typen bereits zur Compilierzeit
	erkannt werden.
	
	Die Modellierung von Referenzen stellt sich als ähnlich problematisch wie bei den bisherigen Java-Datasets dar (\refsec{sec:grundlagen:modellierung:java}). Nach wie vor wächst das Dataset vertikal in der Datei. 
	
	Zumindest das Problem mit den Referenzen kann durch eine Erweiterung auf M2-Ebene etwas entschärft werden 
	(\reflst{listing:sbtestingdataset}).
	
	\lstSetJava
	\begin{lstlisting}[caption=SB Testing Dataset (2), label=listing:sbtestingdataset]
RowBuilder_Professor haase = 
	table_Professor
		.insertRow()
			.setName("Haase")
			.setVorname("Oliver")
			.setTitel("Prof. Dr.")
			.setFakultaet("Informatik");
RowBuilder_Professor waesch = 
	table_Professor
		.insertRow()
			.setName("Wäsch")
			.setVorname("Jürgen")
			.setTitel("Prof. Dr.-Ing.")
			.setFakultaet("Informatik");

RowBuilder_Lehrveranstaltung vsys = 
	table_Lehrveranstaltung
		.insertRow()
			.setName("Verteilte Systeme")
			.refProfessorId(haase)
			.setSws(4)
			.setEcts(5);
RowBuilder_Lehrveranstaltung design_patterns = 
	table_Lehrveranstaltung
		.insertRow()
			.setName("Design Patterns")
			.refProfessorId(haase)
			.setSws(4)
			.setEcts(3);
	\end{lstlisting}

\section{Die DSL}

\subsection{Anforderungen an die DSL}

Die Testdaten sollen in einer \textit{Domain Specific Language} (DSL) beschrieben werden. 

\todo{Anforderungen}
\begin{itemize}
	\item Integration in bestehende Tool-Kette
	\item In Java nutzbar (interne DSL), Dataset soll zur Laufzeit erweiterbar bleiben in selber Syntax
	\item Zugriff auf Daten aus Java heraus
	\item "`Meta-Informtionen als Sprachelement"'
	\item Symbolische Konstanten überflüssig machen
	\item "`Dekorieren"' von Werten (before(date))
	\item wenig syntaktischer Ballast
	\item Typ-Prüfungen zu Compilierzeit
	\item übersichtliche Darstellung ermöglichen (v.a. vertikal)
	\item Namensräume/Scopes
	\item Beziehungen sollen sich einfach und typsicher modellieren lassen
\end{itemize}

\subsection{Zielgruppe}

\subsection{DSL-Entwürfe}

	\subsubsection{Entwurf 1}

	\begin{lstlisting}[caption=Mögliche DSL (1), label=listing:dslentwurf1]
WAESCH = professor {
	name			"Wäsch"
	vorname   "Jürgen"
	titel     "Prof. Dr.-Ing."
  fakultaet "Informatik"
}
	
HAASE = professor {
	name			"Haase"
	vorname   "Oliver"
	titel     "Prof. Dr."
  fakultaet "Informatik"
}

VSYS = lehrveranstaltung {
	name			"Verteilte Systeme"
}
	
DESIGN_PATTERNS = lehrveranstaltung {
	name 			"Design Patterns"
}

...

WAESCH beaufsichtigt P_VSYS
HAASE beaufsichtigt	P_DESIGN_PATTERNS
HAASE leitet VSYS
HAASE leitet DESIGN_PATTERNS
...

	\end{lstlisting}



	\subsubsection{Entwurf 2}

	\begin{lstlisting}[caption=Mögliche DSL (2), label=listing:dslentwurf2]
WAESCH = professor {
	name			"Wäsch"
	vorname   "Jürgen"
	titel     "Prof. Dr.-Ing."
  fakultaet "Informatik"
	beaufsichtigt	P_VSYS
}
	
HAASE = professor {
	name			"Haase"
	vorname   "Oliver"
	titel     "Prof. Dr."
  fakultaet "Informatik"
	beaufsichtigt	P_DESIGN_PATTERNS
	leitet			VSYS, DESIGN_PATTERNS
}

VSYS = lehrveranstaltung {
	name			"Verteilte Systeme"
}
	
DESIGN_PATTERNS = lehrveranstaltung {
	name 			"Design Patterns"
}

...
	\end{lstlisting}

	\subsubsection{Entwurf 3}

	\lstSetTiny
	\begin{lstlisting}[caption=Mögliche DSL (3), label=listing:dslentwurf3]
professor:
	REF    | name    | vorname  | titel            | fakultaet    | beaufsichtigt     | leitet
	WAESCH | "Wäsch" | "Jürgen" | "Prof. Dr.-Ing." | "Informatik" | P_VSYS            |
	HAASE  | "Haase" | "Oliver" | "Prof. Dr."      | "Informatik" | P_DESIGN_PATTERNS | VSYS, DESIGN_PATTERNS
	
lehrveranstaltung:
	REF             | name
	VSYS            | "Verteilte Systeme"
	DESIGN_PATTERNS | "Design Patterns"

...
	\end{lstlisting}
	\lstSetNotmal


