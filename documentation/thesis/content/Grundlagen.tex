\chapter{Grundlegende Konzepte}
\label{chap:grundlagen}

noch zu erklären:
- benutzte Terminologie
- Modellgetriebene Software-Entwicklung
- Tests, Testdatengenerierung
- Literatur nutzen



\section{Modellgetriebene Software-Entwicklung}

In der modellgetriebenen Software-Entwicklung hat sich eine Vier-Schichten-Meta-Architektur etabliert.
Die vier Schichten werden als M0 bis M3 bezeichnet \cite{MOF_141}:
\begin{itemize}
	\item \textbf{M0}: Konkrete Information
	\item \textbf{M1}: Meta-Daten zum Beschreiben der Information. Auch als \textit{Modell} bezeichnet.
	\item \textbf{M2}: Metamodell, das das Modell beschreibt.
	\item \textbf{M3}: Meta-Metamodell, das das Meta-Modell und sich selbst beschreibt.
\end{itemize}

\todo{ergänzen}

- DSL, intern vs. extern



\section{Software-Tests}
\label{sec:grundlagen:konzepte:tests}

\nomenclature{SUT}{System Under Test (\refsec{sec:grundlagen:konzepte:tests})}
Eine zu prüfende Anwendung wird im Kontext von Software-Tests als \textit{System Under Test} (abgekürzt SUT) bezeichnet.
Dabei bezeichnet SUT je nach Test Klassen, Objekte, Methoden oder vollständige Anwendungen. 
\cite[810f]{XUNIT_TEST_PATTERNS}

Alle Voraussetzungen und Vorbedingungen für einen Test werden unter der Bezeichnung \textit{Test Fixture} zusammengefasst.
Ein Test Fixture repräsentiert den Zustand des SUT vor den Tests. \cite[814]{XUNIT_TEST_PATTERNS} Es gibt verschiedene
Arten von Test Fixtures. Folgende zwei Test Fixtures sind für diese Arbeit relevant:

\begin{itemize}
	\item \textbf{Standard Fixture}: Ein Test Fixture wird als Standard Fixture bezeichnet, wenn es für alle bzw. fast alle 
	  Tests verwendet werden kann. Ein Standard Feature reduziert nicht nur den Aufwand zum Entwerfen von Testdaten für die
		einzelnen Tests, sondern verhindert darüber hinaus, dass der Tester sich bei verschiedenen Tests immer wieder
		in unterschiedliche Test-Daten hineinversetzen muss. Nur in Ausnahmefällen sollten Tests modifizierte oder eigene 
		Testdaten verwenden. \cite[305]{XUNIT_TEST_PATTERNS}
	
	\item \textbf{Minimal Fixture}: Minimal Fixtures stellen Test Fixtures dar, deren Umfang auf ein Minimum reduziert wurde. 
	  Dadurch lassen sich Minimal Fixture im Allgemeinen leichter verstehen. Das Reduzieren der Daten kann auch zu
		Leistungsvorteilen bei der Ausführung der Tests führen. \cite[302]{XUNIT_TEST_PATTERNS}
\end{itemize}



Eine übliches Muster, Systeme in Verbindung mit Datenbanken zu testen, ist \textit{Back Door Manipulation}.
Dabei wird die Datenbank über direkten Zugriff, vorbei am zu testenden System, in den Anfangszustand gebracht.
Anschließend können die zu testenden Operationen am System durchgeführt werden. Um zu überprüfen, ob sich das System richtig
verhalten hat, wird der Zustand der Datenbank mit dem erwarteten Zustand verglichen - ebenfalls am zu testenden System vorbei.
\cite[327ff]{XUNIT_TEST_PATTERNS}

\todo{Grafik Back Door Manipulation}

Es gibt mehrere Vorteile, die Datenbank nicht über das zu testende System in den Anfangszustand zu bringen. Einerseits können
semantische Fehler im zu testenden System unter Umständen nur so gefunden werden. Andererseits kann der Zustand mitunter
schneller in die Datenbank geschrieben werden, wenn nicht der Weg über das zu testende System gemacht wird. Außerdem bietet es
in Bezug auf die Zustände eine höhere Flexibilität: Die Datenbank kann auch in Zustände	gebracht werden, die über das System
nicht erreicht werden können. Dafür leidet die Flexibilität an einer anderen Stelle: Die Tests sind abhängig vom konkret
verwendeten Datenbank-System. Wird die Datenbank von SQL auf NoSQL umgestellt, müssen die Tests angepasst werden. 
Außerdem setzt der direkte Zugriff auf die Datenbank voraus, dass die Semantik der
zu testenden Anwendung berücksichtigt wird. Aus Sicht der Anwendung dürfen sich von der Anwendung eingespielte Daten in ihrer
Form nicht von den manuell in die Datenbank geschriebenen Daten unterscheiden.

\todo{Layer test erklären}


\section{DbUnit}

\todo{DataSets erklären}




\section{SB Testing DB}
\label{sec:grundlagen:sbtestingdb}

Die Firma SEITENBAU verwendet für die Java-basierten Datenbankanwendungen das Framework JUnit mit der Erweiterung DbUnit. Da
die Modellierung der Testdaten mit DbUnit-eigenen Mitteln einige Nachteile hat (siehe Abschnitt \ref{sec:fragestellung:modellierung}), hat SEITENBAU die Bibliothek \textit{SB Testing DB} entwickelt.  \textit{SB Testing DB} generiert anhand eines Domänen-spezifischen
Datenbank-Modells ein individuelle Klassen zur Modellierung von Testdaten.

Die generierten Klassen setzen das Builder-Pattern (\cite[11ff]{EFFECTIVEJAVA2ND}) mit einem Fluent API
(\cite[68ff]{DOMAIN_SPECIFIC_LANGUAGES}) um. In Java werden Fluant APIs mit Hilfe von Method Chaining verwirklicht. Dabei
liefern Modifikator-Methoden wie Setter das Host-Objekt selbst zurück. Das erlaubt es, mehrere Modifikationen auf dem selben
Objekt  mit nur einem Ausdruck durchzuführen \cite[373f]{DOMAIN_SPECIFIC_LANGUAGES}. Die Nutzung könnte so aussehen:
\texttt{student.name("Moll").vorname("Nikolaus")}.

Abbildung \ref{img:sbtestingmodel} stellt grafisch dar, wie aus einem Datenbank-Modell das Fluent API erzeugt wird. Ausgangspunkt ist
ein relationales Datenbankmodell. Dieses Modell muss in ein für den Generator interpretierbares Modell, das das SB-Testing-DB-Modell,
transformiert werden. Dies kann automatisch (z.B. wenn das Modell in Form eines \textit{Apache-Torque}-Modell vorliegt) oder manuell
geschehen. Das SB-Testing-DB-Modell enthält Informationen zu Tabellennamen und Angaben zu den Spalten, z.B. Namen und Datentypen. 

\begin{figure}[H]
	\centering
	 \includegraphics[width=0.95\textwidth]{images/grundlagen/sb_testing_model.png}
	\caption{Modell-Beschreibung}\label{img:sbtestingmodel}
\end{figure}

Das SB-Testing-DB-Modell enthält keine Datenbank-Constraints. Eine Abbildung dieser würde keine wesentliche Vorteile bringen. Das API
bzw. die erzeugten DataSets sind ausschließlich für den Einsatz im Test-Umfeld gedacht. Sollte ein DataSet Daten enthalten, die gegen 
die in der Datenbank definierten Constraints verstoßen, scheitert das Einspielen des DataSets in die Datenbank und eine Fehlermeldung
wird ausgelöst.
Aus Sicht des Testers ist dieses Verhalten ausreichend, da die Exception zum Scheitern der Unit-Tests führen wird. Der Mehrwert,
dass ungültige DataSets schon vor dem Einspielen als solches zu erkennen, ist gering im Vergleich zu dem Aufwand, 
Constraint-Mechanismen verschiedener Datenbanksysteme nachzubauen.

Der Generator nutzt für die Code-Generierung \textit{Apache Velocity}. Velocity ist eine Template-Engine, die Dokumente mit Hilfe von
Templates erzeugt. Diese Templates bestehen aus Text und besonderen Velocity-Anweisungen. Zu den Anweisungen gehören unter anderem
Platzhalter, die während der Generierung durch konkrete Werte ausgetauscht werden. Velocity bietet mit Verzweigungen und Schleifen
auch Anweisungen zur Steuerung der Generierung.

Templates Dokumente erzeugt. Die Vorlagen können Platzhalter enthalten, die von Velocity durch konkrete Werte ausgetauscht werden, und
auch von Velocity interpretierte Steueranweisungen, z.B. Verzweigungen und Schleifen.



Die Namen der generierten Klassen hängen vom Modell ab. Unter anderem werden Klassen der folgenden Kategorien erzeugt:
\begin{itemize}

	\item \textbf{DataSet}: Ein DataSet repräsentiert eine Menge von Testdaten dar. Es umfasst alle Tabellen eines
	  Datenbankmodells. 
  	Es wird eine abstrakte DataSet-Klasse generiert. Der Zugriff auf die Tabellen erfolgt über öffentliche
	  Felder. Die Klasse enthält die Methode \texttt{createDBUnitDataSet}, um die für die Unit-Tests benötigten DbUnit-DataSets zu
		erzeugen. Dabei werden Template-Methoden definiert, die genutzt werden können, um in den Erzeugungsprozess von DataSets
		einzugreifen. Die Klasse enthält darüber hinaus Methoden zum Hinzufügen von Zeilen in die entsprechende
		Tabellen.

	\item \textbf{Table}: Eine \texttt{Table}-Klasse fasst alle Testdaten in Form von Zeilen einer Tabelle zusammen.
	  Für jede Tabelle wird eine individuelle Klasse generiert. Der Klassenname setzt sich aus dem Namen
	  der Tabelle und dem Suffix "`Table"' zusammen. Die Klasse stellt Methoden zum Modellieren der Daten und für den Zugriff
		auf Tabellenzeilen bereit. 
		Damit die Klasse direkt zur Erstellung von DbUnit-DataSets verwendet werden kann, implementiert sie das DbUnit-Interface
		\texttt{ITable}.
	
	\item \textbf{RowBuilder}: Eine Zeile einer Tabelle wird von einem \texttt{RowBuilder} repräsentiert. Zu jeder Tabelle wird
	  eine angepasste Klasse \texttt{RowBuilder}-Klasse erzeugt. Sie beinhaltet für jede Spalte mehrere Methoden zum Setzen und
		Abfragen des jeweiligen Wertes. Die Methodennamen setzen sich zusammen aus der Aufgabe (\texttt{get} bzw. \texttt{set}) und
		dem Spaltennamen.
	
	\item \textbf{FindWhere}: Für einfache Suchanfragen gibt es für jede Tabelle die innere Klasse \texttt{FindWhere}. Sie ermöglicht
	  die Suche nach  einem Wert in einer Spalte und liefert eine Liste von Tabellenzeilen. Die Methode ist zur Suche nach Zeilen
		vorgesehen, von denen erwartet wird, dass es sie gibt. Passt keine Zeile zum Suchkriterium gefunden, wird eine
		Exception ausgelöst.
	
\end{itemize}

Abbildung \ref{img:sb_testing_classes} stellt das logische Klassendiagramm der DataSet-Klassen dar. Der Unterschied zum
tatsächlichen Klassendiagramm besteht darin, dass im logischen Diagramm alle \texttt{Table}-Klassen zusammengefasst werden,
obwohl  diese unterschiedlichen Typs sind. Außerdem entsprechen die Klassennamen, bis auf die Klasse \texttt{FindWhere}, nicht
den tatsächlichen Bezeichnern.

\begin{figure}[H]
  \centering
	 \includegraphics[width=0.4\textwidth]{images/grundlagen/sb_testing_classes.pdf}
	\caption{UML-Klassendiagramm der SB Testing DataSet-Klassen}\label{img:sb_testing_classes}
\end{figure}




\section{Konventionen}
\label{sec:grundlagen:konventionen}

	\subsection{Datenbank ER-Diagramme}
	\label{sec:grundlagen:konventionen:datenbankdiagramme}
	Für die Darstellung von Datenbank-Diagrammen wird ein einheitlicher Modellierungsstil verwendet. Dieser basiert auf
	dem UML-Klassendiagramm.
	
	Tabellen werden durch Boxen repräsentiert. Diese Boxen sind unterteilt in zwei Bereiche: den Tabellenbezeichner (oben)
	und die Attribute der Tabelle (unten). Attribute werden in der Form \textit{Bezeichner : typ} beschrieben. Es gibt die
	beiden Stereotypen \textit{PK} für \textit{Primary Key} und \textit{FK} für \textit{Foreign Key}, um die Attribute
	entsprechend zu klassifizieren.
	
	Beziehungen zwischen Tabellen werden durch Verbindungslinien dargestellt. Die Kardinalitäten beschreiben die Art der 
	Verbindung. Die Bedeutung der Kardinalitäten lassen sich am besten über ein Beispiel erklären (Abbildung \ref{img:ambler_table}).
	Eine Entität aus \texttt{TABELLE 1} ist mit mindestens einer und beliebig vielen Entitäten aus \texttt{TABELLE 2}
	in einer Beziehung, jede Entität aus \texttt{TABELLE 2} ist mit genau einer Entität aus \texttt{TABELLE 1} in Beziehung.
	Beziehungen können zusätzlich mit einem Bezeichner versehen werden. 

	Auf die Angabe der Stereotypen für die Tabellen und Beziehungen wird verzichtet.
	
	\begin{figure}[H]
		\centering
		 \includegraphics[width=0.75\textwidth]{images/grundlagen/ambler_table.pdf}
		\caption{Datenbank-Diagramm-Stil nach Ambler}\label{img:ambler_table}
	\end{figure}
	
	Diese Konvention wird auch von Ambler in \cite{REFACTORING_DATABASES} verwendet.