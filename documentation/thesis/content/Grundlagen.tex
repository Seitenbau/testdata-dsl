\chapter{Grundlegende Konzepte}
\label{chap:grundlagen}

noch zu erklären:
- benutzte Terminologie
- Modellgetriebene Software-Entwicklung
- Tests, Testdatengenerierung
- Literatur nutzen



\section{Modellgetriebene Software-Entwicklung}


\begin{itemize}
	\item \textbf{M0}: Konkrete Information
	\item \textbf{M1}: Meta-Daten zum Beschreiben der Information. Auch als \textit{Modell} bezeichnet.
	\item \textbf{M2}: 
	\item \textbf{M3}:
\end{itemize}

- Modell, Meta-Modell, Modell-Ebenen
- http://www.omg.org/spec/MOF/ISO/19502/PDF/ spricht von den klassischen 4 schichten...
- DSL, intern vs. extern



\section{Software-Tests}
\label{sec:grundlagen:konzepte:tests}

\nomenclature{SUT}{System Under Test (\refsec{sec:grundlagen:konzepte:tests})}
Das zu testende System wird im Rahmen von Software-Tests als \textit{System Under Test} (abgekürzt SUT) bezeichnet. Dabei kann
es sich je nach Test und Kontext auf Klassen, Objekte, Methoden, vollständige Anwendungen oder Teile davon beziehen. 
\cite[810f]{XUNIT_TEST_PATTERNS}

Alle Voraussetzungen und Vorbedingungen für einen Testlauf werden unter der Bezeichnung \textit{Test Fixture} zusammengefasst.
Es repräsentiert den Zustand des SUT vor den Tests. \cite[814]{XUNIT_TEST_PATTERNS} Es gibt verschiedene Arten von Test Fixtures.
Die im Rahmen dieser Arbeit relevanten sind \textit{Standard Fixture} und \textit{Minimal Fixture}.

Ein Test Fixture wird als Standard Fixture bezeichnet, wenn es für alle bzw. fast alle Tests verwendet werden kann. Ein Standard
Feature reduziert nicht nur den Aufwand zum Entwerfen von Testdaten für die einzelnen Tests, sondern verhindert darüber hinaus,
dass der Test-Ingenieur  sich bei verschiedenen Tests immer wieder in unterschiedliche Test-Daten hineinversetzen muss. Nur in
Ausnahmefällen sollten Tests modifizierte oder eigene Testdaten verwenden. (\cite[305]{XUNIT_TEST_PATTERNS})

Minimal Fixtures stellen Test Fixtures dar, deren Umfang auf ein Minimum reduziert wurde. Dadurch lassen sich Minimal Fixtures
im Allgemeinen leichter verstehen. Das Reduzieren der Daten kann auch zu Leistungsvorteilen bei der Ausführung der Tests führen.
(\cite[302]{XUNIT_TEST_PATTERNS})

%\subsection{Datenbanktests}
Eine übliche Vorgehensweise, Systeme in Verbindung mit Datenbanken zu testen, stellt \textit{Back Door Manipulation} dar.
Dabei wird die Datenbank über direkten Zugriff, vorbei am zu testenden System, in den Anfangszustand gebracht.
Anschließend können die zu testenden Operationen am System durchgeführt werden. Um zu überprüfen, ob sich das System richtig
verhalten hat, wird der Zustand der Datenbank mit dem erwarteten Zustand verglichen - ebenfalls am zu testenden System vorbei.
\cite[327ff]{XUNIT_TEST_PATTERNS}

\todo{Grafik Back Door Manipulation}

Es gibt mehrere Vorteile, die Datenbank nicht über das zu testende System in den Anfangszustand zu bringen. Einerseits können
semantische Fehler im zu testenden System unter Umständen nur so gefunden werden. Andererseits kann der Zustand mitunter
schneller in die Datenbank geschrieben werden, wenn nicht der Weg über das zu testende System gemacht wird. Außerdem bietet es
in Bezug auf die Zustände eine höhere Flexibilität: Die Datenbank kann auch in Zustände	gebracht werden, die über das System
nicht erreicht werden können. Dafür leidet die Flexibilität an einer anderen Stelle: Die Tests sind abhängig vom konkret
verwendeten Datenbank-System. Außerdem setzt der direkte Zugriff auf die Datenbank voraus, dass die Semantik der
zu testenden Anwendung berücksichtigt wird. Aus Sicht der Anwendung dürfen sich von der Anwendung eingespielte Daten in ihrer
Form nicht von den manuell in die Datenbank geschriebenen Daten unterscheiden.

\todo{Layer test erklären}


\section{DbUnit}

\todo{DataSets erklären}




\section{SB Testing DB}
\label{sec:grundlagen:sbtestingdb}

Die Firma Seitenbau GmbH verwendet für die Java-basierten Datenbankanwendungen das Framework JUnit mit der Erweiterung DbUnit. Da
die Modellierung der Testdaten mit DbUnit-eigenen Mitteln einige Nachteile hat (siehe Abschnitt \ref{sec:fragestellung:modellierung}), hat Seitenbau die Bibliothek SB Testing DB entwickelt. SB Testing DB verfolgt keinen generischen Ansatz, der eine Standard-API für die Modellierung von DataSets definieren würde. Stattdessen wird für jedes Datenbank-Modell ein individuelles API bzw. eine interne 
Java-DSL generiert.

Abbildung \ref{img:sbtestingmodel} stellt grafisch dar, wie aus einem Datenbank-Modell die Java-DSL erzeugt wird. Ausgangspunkt ist
ein relationales Datenbankmodell. üblicherweise liegt es bei Seitenbau als \textit{Apache-Torque}-Modell im XML-Format vor. Dieses
muss vor der eigentlichen Code-Erzeugung in ein für den Generator interpretierbares Modell (das SB-Testing-DB-Modell) transformiert
werden, das die Meta-Informationen zur Datenbank enthält. Zu den notwendigen Meta-Informationen gehören Tabellennamen und Daten zu den
Spalten, z.B. Name und Datentypen. Das SB-Testing-DB-Modell kann manuell gepflegt und auch vollständig manuell entwickelt werden. Mit
Hilfe des SB-Testing-DB-Modells erzeugt der Generator die interne Java-DSL (DSL Model).

\begin{figure}[H]
	\centering
	 \includegraphics[width=0.95\textwidth]{images/grundlagen/sb_testing_model.png}
	\caption{Modell-Beschreibung}\label{img:sbtestingmodel}
\end{figure}

Das SB-Testing-DB-Modell enthält keine Datenbank-Constraints und eine Abbildung dieser bringt keine wesentliche Vorteile. Das API bzw.
die erzeugten DataSets sind ausschließlich für den Einsatz Test-Umfeld gedacht. Sollte ein DataSet Daten enthalten, die gegen die
in der Datenbank definierten Constraints verstoßen, scheitert das Einspielen des DataSets und eine Exception wird ausgelöst. Aus
Sicht des Testers ist dieses Verhalten ausreichend, da die Exception zum Scheitern der Unit-Tests führen wird. Der Mehrwert,
das ungültige DataSets schon vor dem Einspielen als solches zu erkennen, ist minimal im Vergleich zu dem Aufwand, Constraints
verschiedener Datenbanken nachzubauen.

Der Generator erzeugt die Java-Klassen mit Hilfe von \textit{Apache Velocity}. Velocity ist eine sogenannte Template-Engine, die aus
Vorlagen Dokumente erzeugt. Die Vorlagen können Platzhalter enthalten, die von Velocity durch konkrete Werte ausgetauscht werden, und
auch von Velocity interpretierte Steueranweisungen, z.B. Verzweigungen und Schleifen.

Unter anderem werden Klassen der folgenden Kategorien erzeugt:
\begin{itemize}

	\item \textbf{DataSet}: Es wird eine abstrakte DataSet-Klasse generiert. Der Zugriff auf die Tabellen erfolgt über öffentliche
	  Felder. Die Klasse enthält die Fabrikmethode \texttt{createDBUnitDataSet} zur Erzeugung eines DbUnit-DataSets. Dabei werden
		Template-Methoden definiert, die genutzt werden können, um in den Erzeungsprozess von DataSets einzugreifen. Die Klasse enthält
		darüber hinaus einige Convenience-Methoden zum Hinzufügen von Zeilen in die entsprechende Tabellen.

	\item \textbf{Table}:
	
	\item \textbf{RowBuilder}:
	
	\item \textbf{FindWhere}:

\end{itemize}

\todo{einfaches Klassendiagramm für SB Testing DB generierte Klassen}




\section{Konventionen}
\label{sec:grundlagen:konventionen}

	\subsection{Datenbank-Diagramme}
	\label{sec:grundlagen:konventionen:datenbankdiagramme}
	Für die Darstellung von Datenbank-Diagrammen wird ein einheitlicher Stil verwendet. Dieser orientiert sich an
	Ambler aus \cite{REFACTORING_DATABASES}. Auf die Angabe von Stereotypen wird sowohl bei den Tabellen, als auch
	bei den Beziehungen zwischen Tabellen verzichtet.
	
	Erklären:
	- Spalten/PK/FK
	- Kardinalitäten
	
	Abbildung \ref{img:ambler_table} zeigt ein Diagramm mit zwei Tabellen. Tabelle 2 enthält einen Fremdschlüssel,
	der einem Primärschlüssel aus Tabelle 1 

	\begin{figure}[H]
		\centering
		 \includegraphics[width=0.75\textwidth]{images/grundlagen/ambler_table.pdf}
		\caption{Datenbank-Diagramm-Stil nach Ambler}\label{img:ambler_table}
	\end{figure}

